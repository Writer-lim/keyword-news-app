<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <title>ì˜¤ëª© ê²Œì„ (ê³ ì„±ëŠ¥ AI) ğŸ”´âš«</title>
    <style>
        /* **ê¸°ë³¸ ìŠ¤íƒ€ì¼** */
        body { 
            font-family: 'Arial', sans-serif; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            background-color: #f0f2f5; 
            margin: 0;
            padding: 0;
        }
        .container { 
            max-width: 600px; 
            margin: 20px auto;
            padding: 20px; 
            background: white; 
            border-radius: 8px; 
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); 
        }
        h1 { text-align: center; color: #333; }
        #nav a { margin: 0 10px; text-decoration: none; color: #007bff; }
        
        #controls { margin-bottom: 20px; display: flex; flex-direction: column; align-items: center; }
        #controls button, #controls select { padding: 8px 15px; margin: 5px; cursor: pointer; border-radius: 4px; border: 1px solid #ddd; }
        #controls button.active { background-color: #007bff; color: white; border-color: #007bff; }
        
        /* **ì˜¤ëª©íŒ CSS: ì •ë ¬ ì¬ë³´ì •** */
        #board-wrapper {
            position: relative;
            width: 95vw;
            max-width: 580px; 
            aspect-ratio: 1 / 1; 
            
            background-color: #e3b772;
            border: 1px solid #000; 
            user-select: none;
            
            /* GridëŠ” ì„ ì„ ê·¸ë¦¬ëŠ” ì—­í• ë§Œ ë‹´ë‹¹ (14x14 ê°„ê²©) */
            display: grid;
            grid-template-rows: repeat(14, 1fr);
            grid-template-columns: repeat(14, 1fr);
            padding: 0;
        }
        
        /* ì„  ê·¸ë¦¬ê¸°ìš© Grid */
        #lines-grid {
             position: absolute;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%;
             display: grid;
             grid-template-rows: repeat(14, 1fr);
             grid-template-columns: repeat(14, 1fr);
        }
        .grid-line {
            border-right: 1px solid black;
            border-bottom: 1px solid black;
        }
        #lines-grid > .grid-line:nth-child(14n) { border-right: none; }
        #lines-grid > .grid-line:nth-last-child(-n + 14) { border-bottom: none; }
        
        /* **ì°©ìˆ˜ ì˜ì—­ (Intersections) ì •ì˜: 15x15** */
        #intersections {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100;
            
            /* 15x15 Grid: ëª¨ë“  êµì°¨ì ì„ í¬í•¨ */
            display: grid;
            grid-template-rows: repeat(15, 1fr); 
            grid-template-columns: repeat(15, 1fr);
        }
        
        /* **í´ë¦­ ê°€ëŠ¥ ì˜ì—­ (ì°©ìˆ˜ ë¶ˆê°€ ì˜¤ë¥˜ í•´ê²° í•µì‹¬)** */
        .intersection {
            cursor: pointer;
            position: relative;
            /* **í´ë¦­ ì˜ì—­ì„ CELL_SIZE í¬ê¸°ë¡œ í™•ì¥** */
            width: 100%; 
            height: 100%;
            z-index: 10;
        }
        
        /* **ëŒ ìŠ¤íƒ€ì¼: êµì°¨ì  ì¤‘ì•™ì— ì˜¤ë„ë¡ ìµœì¢… ë³´ì •** */
        .stone, .preview {
            border-radius: 50%;
            position: absolute;
            top: 0; 
            left: 0;
            /* ëŒì˜ ì¤‘ì‹¬ì„ intersection cellì˜ ì¢Œìƒë‹¨ ëª¨ì„œë¦¬(Grid êµì°¨ì )ì— ì˜¤ë„ë¡ ì¡°ì • */
            transform: translate(-50%, -50%); 
            z-index: 20;
        }
        .black { background-color: black; }
        .white { background-color: white; border: 1px solid #333; }

        .preview {
            opacity: 0.4; 
            z-index: 19;
            pointer-events: none;
        }
        
        #status { margin-top: 20px; font-size: 1.2em; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <div id="nav" style="text-align: center; margin-bottom: 20px;">
            <a href="/">ë©”ì¸ í˜ì´ì§€ë¡œ ëŒì•„ê°€ê¸°</a>
        </div>
        <h1>ì˜¤ëª© AI ëŒ€ì „ ğŸ”´âš«</h1>
        
        <div id="controls">
            <div style="margin-bottom: 10px;">
                <button id="mode-user-ai" data-mode="user-ai" class="active">ì‚¬ìš©ì vs AI</button>
                <button id="mode-ai-ai" data-mode="ai-ai">AI vs AI</button>
            </div>
            
            <div>
                <label for="difficulty">AI ë‚œì´ë„:</label>
                <select id="difficulty">
                    <option value="1">í•˜ìˆ˜ (Depth 1)</option>
                    <option value="3" selected>ì¤‘ìˆ˜ (Depth 3)</option>
                    <option value="5">ê³ ìˆ˜ (Depth 5)</option>
                </select>
                <button onclick="startGame()">ìƒˆ ê²Œì„ ì‹œì‘</button>
            </div>
        </div>

        <div id="board-wrapper">
             <div id="lines-grid"></div> 
             <div id="intersections"></div>
        </div>
        
        <div id="status">ê²Œì„ì„ ì‹œì‘í•´ ì£¼ì„¸ìš”.</div>
    </div>

    <script>
        const boardWrapper = document.getElementById('board-wrapper');
        const linesGrid = document.getElementById('lines-grid');
        const intersectionsElement = document.getElementById('intersections');
        const statusElement = document.getElementById('status');
        
        const BOARD_SIZE = 15; 
        let CELL_SIZE = 30; 

        let board = [];
        let currentPlayer = 1; 
        let gameOver = false;
        let currentMode = 'user-ai';
        let aiDepth = 3; 
        
        window.addEventListener('resize', () => {
             if (!gameOver) initializeBoard(); 
        });
        
        // --- ì´ˆê¸°í™” ë° UI ë¡œì§ (ì •ë ¬ ì¬ë³´ì •) ---
        function initializeBoard() {
             // 1. CELL_SIZE ê³„ì‚°
             const boardWidth = boardWrapper.clientWidth;
             CELL_SIZE = boardWidth / (BOARD_SIZE - 1); // 14ê°œ ê°„ê²© ê¸°ë°˜

             // 2. Lines Grid ì¬ìƒì„± (14x14)
             linesGrid.innerHTML = '';
             linesGrid.style.width = `${boardWidth}px`;
             linesGrid.style.height = `${boardWidth}px`;

             for (let i = 0; i < (BOARD_SIZE - 1) * (BOARD_SIZE - 1); i++) {
                 const line = document.createElement('div');
                 line.className = 'grid-line';
                 linesGrid.appendChild(line);
             }

             // 3. Intersections Grid ì¬ìƒì„± (15x15)
             intersectionsElement.innerHTML = '';
             
             board = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(0));
             
             for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const intersection = document.createElement('div');
                    intersection.className = 'intersection';
                    
                    intersection.dataset.row = r;
                    intersection.dataset.col = c;
                    
                    intersection.addEventListener('mouseover', showPreview);
                    intersection.addEventListener('mouseout', hidePreview);
                    
                    // **[í•µì‹¬ ìˆ˜ì •] ì°©ìˆ˜ ë¶ˆê°€ ë¬¸ì œ í•´ê²°: í´ë¦­ ì´ë²¤íŠ¸ ì¬ì—°ê²°**
                    intersection.addEventListener('click', handleMove); 
                    intersectionsElement.appendChild(intersection);
                }
            }
            gameOver = false;
        }

        // --- ìš”ì†Œ ì ‘ê·¼ ë° UI ê·¸ë¦¬ê¸° ---

        function getCellElement(r, c) {
            return intersectionsElement.children[(r * BOARD_SIZE) + c]; 
        }

        function drawStoneOnUI(r, c, player) {
            const stone = document.createElement('div');
            stone.className = `stone ${player === 1 ? 'black' : 'white'}`;
            
            // ëŒ í¬ê¸° ì„¤ì • (CELL_SIZEì— ë¹„ë¡€)
            stone.style.width = `${CELL_SIZE * 0.9}px`;
            stone.style.height = `${CELL_SIZE * 0.9}px`;

            const cell = getCellElement(r, c);
            
            while (cell.firstChild) {
                cell.removeChild(cell.firstChild);
            }
            if (cell) {
                 cell.appendChild(stone);
            }
        }
        
        // --- ê²Œì„ íë¦„ ì œì–´ ---

        function handleMove(event) {
            if (gameOver || currentMode !== 'user-ai' || currentPlayer !== 1) return; 

            const r = parseInt(event.target.dataset.row);
            const c = parseInt(event.target.dataset.col);

            if (board[r][c] === 0) {
                 // **[ë°”ë‘‘ ë¡œì§ ì œê±°] ì˜¤ëª©ì€ ì°©ìˆ˜ ê¸ˆì§€/ìì‚´ ê¸ˆì§€ ë¡œì§ ì—†ìŒ**
                 
                 // íŒì—… ì—†ì´ ë°”ë¡œ ì°©ìˆ˜
                 placeStone(r, c, 1); 
                
                if (!gameOver) {
                    statusElement.textContent = 'ë°±ëŒ (AI)ì´ ìƒê° ì¤‘...';
                    setTimeout(makeAIMove, 500); 
                }
            }
        }

        function placeStone(r, c, player) {
            board[r][c] = player;
            drawStoneOnUI(r, c, player);
            
            if (checkWin(r, c, player)) {
                const winner = player === 1 ? 'í‘ëŒ' : 'ë°±ëŒ';
                statusElement.textContent = `${winner} ìŠ¹ë¦¬! ğŸ‰`;
                gameOver = true;
            } else {
                currentPlayer = player === 1 ? 2 : 1; 
                if (currentMode === 'user-ai' && currentPlayer === 1) {
                    statusElement.textContent = 'í‘ëŒ ì°¨ë¡€ì…ë‹ˆë‹¤.';
                }
            }
        }
        
        // --- ìŠ¹ë¦¬ íŒì • êµ¬í˜„ (ìœ ì§€) ---
        function checkWin(r, c, player) {
            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
            for (const [dr, dc] of directions) {
                let count = 1;
                for (let i = 1; i < 5; i++) {
                    const nr = r + dr * i;
                    const nc = c + dc * i;
                    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === player) {
                        count++;
                    } else { break; }
                }
                for (let i = 1; i < 5; i++) {
                    const nr = r - dr * i;
                    const nc = c - dc * i;
                    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === player) {
                        count++;
                    } else { break; }
                }
                if (count >= 5) { return true; }
            }
            return false;
        }

        // --- AI ë¡œì§ êµ¬í˜„ (ìœ ì§€) ---
        function makeAIMove() {
            if (gameOver || currentPlayer !== 2) return; 
            const aiPlayer = currentPlayer; 
            let bestMove = findBestMove(aiPlayer, aiDepth); 
            if (bestMove) { placeStone(bestMove.r, bestMove.c, aiPlayer); }
        }

        function findBestMove(player, depth) { 
             const opponent = player === 1 ? 2 : 1;
             const emptySpots = [];
             for(let r=0; r<BOARD_SIZE; r++) {
                 for(let c=0; c<BOARD_SIZE; c++) {
                     if(board[r][c] === 0) emptySpots.push({r, c});
                 }
             }

             if (emptySpots.length === 0) return null;
             
             // 1. í˜„ì¬ ìˆ˜ê°€ ìŠ¹ë¦¬í•˜ëŠ”ì§€ í™•ì¸
             for (const {r, c} of emptySpots) {
                 board[r][c] = player;
                 if (checkWin(r, c, player)) { board[r][c] = 0; return {r, c}; }
                 board[r][c] = 0;
             }
             
             // 2. ìƒëŒ€ë°©ì´ ë‹¤ìŒ ìˆ˜ì— ìŠ¹ë¦¬í•˜ëŠ” ê²ƒì„ ë§‰ëŠ”ì§€ í™•ì¸
             for (const {r, c} of emptySpots) {
                 board[r][c] = opponent; 
                 if (checkWin(r, c, opponent)) { board[r][c] = 0; return {r, c}; }
                 board[r][c] = 0;
             }
             
             // 3. ì£¼ë³€ì— ì°©ìˆ˜ (ì„ì‹œ íœ´ë¦¬ìŠ¤í‹±)
             let neighbors = emptySpots.filter(({r, c}) => {
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        const nr = r + dr;
                        const nc = c + dc;
                        if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] !== 0) {
                            return true;
                        }
                    }
                }
                return false;
             });
             
             if (neighbors.length > 0) {
                 return neighbors[Math.floor(Math.random() * neighbors.length)];
             }
             
             // 4. ì¤‘ì•™ ì°©ìˆ˜
             return emptySpots[Math.floor(Math.random() * emptySpots.length)];
        }
        
        // --- ê¸°íƒ€ UI ì»¨íŠ¸ë¡¤ í•¨ìˆ˜ ---
        document.querySelectorAll('#controls button[data-mode]').forEach(button => { /* ... */ });
        document.getElementById('difficulty').addEventListener('change', (e) => { aiDepth = parseInt(e.target.value); });
        function showPreview(event) { /* ... */ }
        function hidePreview(event) { /* ... */ }
        function startGame() { /* ... */ }

        window.onload = initializeBoard;
    </script>
</body>
</html>