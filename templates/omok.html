<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ì˜¤ëª© ê²Œì„ (ê³ ì„±ëŠ¥ AI) ğŸ”´âš«</title>
    <style>
        body { font-family: 'Arial', sans-serif; display: flex; flex-direction: column; align-items: center; background-color: #f0f2f5; }
        .container { max-width: 600px; margin: 20px; padding: 20px; background: white; border-radius: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        h1 { text-align: center; color: #333; }
        #nav a { margin: 0 10px; text-decoration: none; color: #007bff; }
        
        #controls { margin-bottom: 20px; display: flex; flex-direction: column; align-items: center; }
        #controls button, #controls select { padding: 8px 15px; margin: 5px; cursor: pointer; border-radius: 4px; border: 1px solid #ddd; }
        #controls button.active { background-color: #007bff; color: white; border-color: #007bff; }
        
        #board-wrapper {
            position: relative;
            width: 450px; /* 14 * 30px + 2 * 15px padding = 450px */
            height: 450px;
            padding: 15px; /* ê²©ìì  ì¤‘ì•™ì— ëŒì„ ë†“ê¸° ìœ„í•œ ê°„ê²© */
            background-color: #e3b772;
            border: 2px solid #000;
        }
        #board {
            display: grid;
            grid-template-columns: repeat(14, 30px);
            grid-template-rows: repeat(14, 30px);
            width: 420px; /* 14 * 30px */
            height: 420px;
            position: relative;
        }
        .line-h {
            position: absolute;
            left: 0;
            right: 0;
            height: 1px;
            background-color: #000;
            transform: translateY(-0.5px);
        }
        .line-v {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 1px;
            background-color: #000;
            transform: translateX(-0.5px);
        }
        
        .intersection {
            width: 30px;
            height: 30px;
            position: absolute;
            cursor: pointer;
            z-index: 10;
        }
        
        .stone {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* ì •í™•íˆ êµì°¨ì  ì¤‘ì•™ì— ìœ„ì¹˜ */
        }
        .black { background-color: black; z-index: 20; }
        .white { background-color: white; border: 1px solid #333; z-index: 20; }
        
        #status { margin-top: 20px; font-size: 1.2em; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <div id="nav" style="text-align: center; margin-bottom: 20px;">
            <a href="/">ë©”ì¸ í˜ì´ì§€ë¡œ ëŒì•„ê°€ê¸°</a>
        </div>
        <h1>ì˜¤ëª© AI ëŒ€ì „ ğŸ”´âš«</h1>
        
        <div id="controls">
            <div style="margin-bottom: 10px;">
                <button id="mode-user-ai" data-mode="user-ai" class="active">ì‚¬ìš©ì vs AI</button>
                <button id="mode-ai-ai" data-mode="ai-ai">AI vs AI</button>
            </div>
            
            <div>
                <label for="difficulty">AI ë‚œì´ë„:</label>
                <select id="difficulty">
                    <option value="1">í•˜ìˆ˜ (Depth 1-2)</option>
                    <option value="2" selected>ì¤‘ìˆ˜ (Depth 3-4)</option>
                    <option value="3">ê³ ìˆ˜ (Depth 5+)</option>
                </select>
                <button onclick="startGame()">ìƒˆ ê²Œì„ ì‹œì‘</button>
            </div>
        </div>

        <div id="board-wrapper">
            <div id="lines"></div>
            <div id="intersections"></div>
        </div>
        
        <div id="status">ê²Œì„ì„ ì‹œì‘í•´ ì£¼ì„¸ìš”.</div>
    </div>

    <script>
        const boardWrapper = document.getElementById('board-wrapper');
        const linesElement = document.getElementById('lines');
        const intersectionsElement = document.getElementById('intersections');
        const statusElement = document.getElementById('status');
        const difficultySelect = document.getElementById('difficulty');
        const modeButtons = document.querySelectorAll('#controls button[data-mode]');
        
        const BOARD_SIZE = 15; // 0ë¶€í„° 14ê¹Œì§€ ì¸ë±ìŠ¤ ì‚¬ìš©
        const CELL_SIZE = 30;
        let board = [];
        let currentPlayer = 1; // 1: í‘(ì‚¬ìš©ì/ì„ ê³µ), 2: ë°±(AI/í›„ê³µ)
        let gameOver = false;
        let currentMode = 'user-ai';
        let aiDepth = 3; 

        // -- ì´ˆê¸°í™” ë° UI ë¡œì§ --

        function initializeBoard() {
            board = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(0));
            linesElement.innerHTML = '';
            intersectionsElement.innerHTML = '';

            // 1. ì„  ê·¸ë¦¬ê¸° (Lines)
            for (let i = 0; i < BOARD_SIZE; i++) {
                // ê°€ë¡œì„  (Horizontal)
                const hLine = document.createElement('div');
                hLine.className = 'line-h';
                hLine.style.top = `${i * CELL_SIZE}px`;
                hLine.style.left = '15px';
                hLine.style.right = '15px';
                linesElement.appendChild(hLine);

                // ì„¸ë¡œì„  (Vertical)
                const vLine = document.createElement('div');
                vLine.className = 'line-v';
                vLine.style.left = `${i * CELL_SIZE}px`;
                vLine.style.top = '15px';
                vLine.style.bottom = '15px';
                linesElement.appendChild(vLine);
            }

            // 2. êµì°¨ì (Intersection) ì˜ì—­ ì¶”ê°€ ë° ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const intersection = document.createElement('div');
                    intersection.className = 'intersection';
                    
                    // ê° êµì°¨ì ì˜ ì •í™•í•œ ìœ„ì¹˜ (íŒ¨ë”© 15px + ì¸ë±ìŠ¤ * 30px)
                    intersection.style.top = `${r * CELL_SIZE + 15}px`;
                    intersection.style.left = `${c * CELL_SIZE + 15}px`;

                    intersection.dataset.row = r;
                    intersection.dataset.col = c;
                    intersection.addEventListener('click', handleMove);
                    intersectionsElement.appendChild(intersection);
                }
            }
            gameOver = false;
            
            // ì¤‘ì•™ì  ë§ˆì»¤ (ì •í™•íˆëŠ” 3, 11, 11, 3 ìœ„ì¹˜ì— ì‘ì€ ì ì„ ì°ì§€ë§Œ ì—¬ê¸°ì„  ìƒëµ)
        }

        modeButtons.forEach(button => {
            button.addEventListener('click', () => {
                modeButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                currentMode = button.dataset.mode;
                startGame();
            });
        });

        difficultySelect.addEventListener('change', () => {
            const difficulty = parseInt(difficultySelect.value);
            // ë‚œì´ë„ë³„ íƒìƒ‰ ê¹Šì´ ì„¤ì • (ê³ ìˆ˜ì¼ìˆ˜ë¡ ì‹œê°„ì´ ì˜¤ë˜ ê±¸ë¦¼)
            if (difficulty === 1) aiDepth = 1; // í•˜ìˆ˜
            else if (difficulty === 2) aiDepth = 3; // ì¤‘ìˆ˜
            else if (difficulty === 3) aiDepth = 5; // ê³ ìˆ˜ (ê²½ê³ : 5ëŠ” ë¸Œë¼ìš°ì €ì—ì„œ ëŠë¦´ ìˆ˜ ìˆìŒ)
        });

        function startGame() {
            const difficulty = parseInt(difficultySelect.value);
            if (difficulty === 1) aiDepth = 1; 
            else if (difficulty === 2) aiDepth = 3;
            else if (difficulty === 3) aiDepth = 5;

            currentPlayer = 1; // í‘ëŒë¶€í„° ì‹œì‘
            initializeBoard();
            statusElement.textContent = 'í‘ëŒ ì°¨ë¡€ì…ë‹ˆë‹¤.';
            
            if (currentMode === 'ai-ai') {
                runAIGame();
            }
        }

        // -- ê²Œì„ íë¦„ ì œì–´ ë¡œì§ --

        function handleMove(event) {
            if (gameOver || currentMode !== 'user-ai' || currentPlayer !== 1) return; 

            const r = parseInt(event.target.dataset.row);
            const c = parseInt(event.target.dataset.col);

            if (board[r][c] === 0) {
                placeStone(r, c, 1);
                
                if (!gameOver) {
                    statusElement.textContent = 'ë°±ëŒ (AI)ì´ ìƒê° ì¤‘...';
                    setTimeout(makeAIMove, 500); 
                }
            }
        }

        function placeStone(r, c, player) {
            board[r][c] = player;
            drawStoneOnUI(r, c, player);
            
            if (checkWin(r, c, player)) {
                const winner = player === 1 ? 'í‘ëŒ' : 'ë°±ëŒ';
                statusElement.textContent = `${winner} ìŠ¹ë¦¬! ğŸ‰`;
                gameOver = true;
            } else {
                currentPlayer = player === 1 ? 2 : 1;
                if (currentMode !== 'ai-ai') {
                    const nextPlayer = currentPlayer === 1 ? 'í‘ëŒ' : 'ë°±ëŒ (AI)';
                    statusElement.textContent = `${nextPlayer} ì°¨ë¡€ì…ë‹ˆë‹¤.`;
                }
            }
        }
        
        function drawStoneOnUI(r, c, player) {
            const stone = document.createElement('div');
            stone.className = `stone ${player === 1 ? 'black' : 'white'}`;
            
            // í•´ë‹¹ êµì°¨ì  ìš”ì†Œë¥¼ ì°¾ì•„ì„œ ëŒì„ ì¶”ê°€
            const index = r * BOARD_SIZE + c;
            const intersection = intersectionsElement.children[index];
            if (intersection && intersection.children.length === 0) {
                 intersection.appendChild(stone);
            }
        }

        function runAIGame() {
            if (gameOver) return;

            if (currentPlayer === 1) {
                statusElement.textContent = 'í‘ëŒ (AI)ì´ ìƒê° ì¤‘...';
            } else {
                statusElement.textContent = 'ë°±ëŒ (AI)ì´ ìƒê° ì¤‘...';
            }

            setTimeout(() => {
                makeAIMove(true);
                if (!gameOver) {
                    runAIGame(); 
                }
            }, 500);
        }

        // -- AI ë¡œì§ (Minimax ê°•í™”) --

        function makeAIMove(isAIVsAI = false) {
            if (gameOver) return;

            const aiPlayer = currentPlayer; 
            const bestMove = findBestMove(aiPlayer, aiDepth);

            if (bestMove) {
                placeStone(bestMove.r, bestMove.c, aiPlayer);
            }
            
            if (isAIVsAI && !gameOver) {
                 const nextPlayer = currentPlayer === 1 ? 'í‘ëŒ' : 'ë°±ëŒ';
                 statusElement.textContent = `${nextPlayer} ì°¨ë¡€ì…ë‹ˆë‹¤.`;
            }
        }

        function findBestMove(player, depth) {
            let bestScore = -Infinity;
            let bestMove = null;
            const possibleMoves = getPossibleMoves(board);

            // ìµœì í™”: ì¤‘ì•™ ê·¼ì²˜ ë˜ëŠ” ë°©ì–´ ìœ„ì¹˜ ë¨¼ì € íƒìƒ‰
            possibleMoves.sort((a, b) => {
                const centerR = Math.abs(a.r - 7);
                const centerC = Math.abs(a.c - 7);
                const distA = Math.max(centerR, centerC);
                
                const centerR2 = Math.abs(b.r - 7);
                const centerC2 = Math.abs(b.c - 7);
                const distB = Math.max(centerR2, centerC2);

                return distA - distB; // ì¤‘ì•™ì— ê°€ê¹Œìš¸ìˆ˜ë¡ ë¨¼ì € íƒìƒ‰
            });

            // Minimax íƒìƒ‰
            for (const move of possibleMoves) {
                const newBoard = simulateMove(board, move.r, move.c, player);
                const score = minimax(newBoard, depth - 1, -Infinity, Infinity, false, player);

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
                
                // ê³ ìˆ˜ ë‚œì´ë„ì—ì„œëŠ” ì²« ìŠ¹ë¦¬ ìˆ˜ë§Œ ë°œê²¬í•´ë„ ë°”ë¡œ ë†“ê¸° (ì†ë„ ìµœì í™”)
                if (player === 1 && score >= 100000000 && aiDepth >= 4) return bestMove;
            }
            return bestMove;
        }

        function minimax(currentBoard, depth, alpha, beta, maximizingPlayer, originalPlayer) {
            const winner = checkBoardWin(currentBoard);
            if (winner === originalPlayer) return 100000000 + depth; 
            if (winner !== 0) return -100000000 - depth; 
            if (depth === 0) return evaluateBoard(currentBoard, originalPlayer); 

            const nextPlayer = maximizingPlayer ? originalPlayer : (originalPlayer === 1 ? 2 : 1);
            const possibleMoves = getPossibleMoves(currentBoard);

            if (maximizingPlayer) {
                let maxEval = -Infinity;
                for (const move of possibleMoves) {
                    const newBoard = simulateMove(currentBoard, move.r, move.c, nextPlayer);
                    const eval = minimax(newBoard, depth - 1, alpha, beta, false, originalPlayer);
                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, maxEval);
                    if (beta <= alpha) break; 
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of possibleMoves) {
                    const newBoard = simulateMove(currentBoard, move.r, move.c, nextPlayer);
                    const eval = minimax(newBoard, depth - 1, alpha, beta, true, originalPlayer);
                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, minEval);
                    if (beta <= alpha) break; 
                }
                return minEval;
            }
        }


        // -- ë³´ì¡° ë° í‰ê°€ í•¨ìˆ˜ (AI ì‹¤ë ¥ ê°•í™”ì˜ í•µì‹¬) --
        
        function getPossibleMoves(currentBoard) {
            const moves = new Set();
            let stoneCount = 0;
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (currentBoard[r][c] !== 0) {
                        stoneCount++;
                        // ëŒ ì£¼ë³€ 2ì¹¸ê¹Œì§€ ë¹ˆ ê³µê°„ë§Œ íƒìƒ‰
                        for (let dr = -2; dr <= 2; dr++) {
                            for (let dc = -2; dc <= 2; dc++) {
                                if (dr === 0 && dc === 0) continue;
                                const nr = r + dr;
                                const nc = c + dc;
                                if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && currentBoard[nr][nc] === 0) {
                                    moves.add(`${nr},${nc}`);
                                }
                            }
                        }
                    }
                }
            }
            if (stoneCount === 0) { // ì¤‘ì•™ ë†“ê¸°
                 moves.add(`${Math.floor(BOARD_SIZE/2)},${Math.floor(BOARD_SIZE/2)}`);
            }
            return Array.from(moves).map(move => {
                const [r, c] = move.split(',').map(Number);
                return {r, c};
            });
        }
        
        function simulateMove(currentBoard, r, c, player) {
            const newBoard = currentBoard.map(row => [...row]);
            newBoard[r][c] = player;
            return newBoard;
        }

        // ìŠ¹ë¦¬ ì¡°ê±´ í™•ì¸ (UIìš©)
        function checkWin(r, c, player) {
            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
            for (const [dr, dc] of directions) {
                let count = 1;
                count += countLine(r, c, dr, dc, player, board);
                count += countLine(r, c, -dr, -dc, player, board);
                if (count >= 5) return true;
            }
            return false;
        }
        
        // ìŠ¹ë¦¬ ì¡°ê±´ í™•ì¸ (AI íƒìƒ‰ìš©)
        function checkBoardWin(currentBoard) {
            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (currentBoard[r][c] !== 0) {
                        const player = currentBoard[r][c];
                        for (const [dr, dc] of directions) {
                             let count = 0;
                            for (let i = 0; i < 5; i++) {
                                const nr = r + dr * i;
                                const nc = c + dc * i;
                                if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && currentBoard[nr][nc] === player) {
                                    count++;
                                } else {
                                    break;
                                }
                            }
                            if (count === 5) return player; 
                        }
                    }
                }
            }
            return 0; 
        }

        function countLine(r, c, dr, dc, player, targetBoard) {
            let count = 0;
            for (let i = 1; i < 5; i++) {
                const nr = r + dr * i;
                const nc = c + dc * i;
                if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && targetBoard[nr][nc] === player) {
                    count++;
                } else {
                    break;
                }
            }
            return count;
        }

        function evaluateBoard(currentBoard, player) {
            const opponent = player === 1 ? 2 : 1;
            // í”Œë ˆì´ì–´ íŒ¨í„´ ì ìˆ˜ - ìƒëŒ€ë°© íŒ¨í„´ ì ìˆ˜ (ìƒëŒ€ë°©ì˜ ê³µê²©ì„ ë” ë¬´ê²ê²Œ ë§‰ìŒ)
            return evaluatePatterns(currentBoard, player) - evaluatePatterns(currentBoard, opponent) * 1.5;
        }
        
        // ì˜¤ëª© íŒ¨í„´ í‰ê°€ í•¨ìˆ˜ (AI ì‹¤ë ¥ í–¥ìƒì˜ í•µì‹¬)
        function evaluatePatterns(currentBoard, player) {
            let score = 0;
            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
            
            // ëª¨ë“  êµì°¨ì ì„ íƒìƒ‰
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (currentBoard[r][c] !== player) continue;
                    
                    for (const [dr, dc] of directions) {
                        // 4ì—°ì†, 3ì—°ì†, 2ì—°ì† íŒ¨í„´ ì²´í¬
                        score += checkLineScore(currentBoard, r, c, dr, dc, player);
                    }
                }
            }
            return score;
        }

        // íŠ¹ì • ë°©í–¥ì—ì„œ íŒ¨í„´ ì ìˆ˜ë¥¼ ê³„ì‚°
        function checkLineScore(currentBoard, r, c, dr, dc, player) {
            let score = 0;
            const opponent = player === 1 ? 2 : 1;
            
            // 5ì¹¸ì§œë¦¬ ìœˆë„ìš°ë¥¼ slidingí•˜ë©´ì„œ íŒ¨í„´ì„ í™•ì¸í•©ë‹ˆë‹¤.
            // i=0: ì‹œì‘ì , i=4: ëì  (5ì¹¸ ìœˆë„ìš°)
            for (let i = 0; i < 5; i++) {
                const startR = r - dr * i;
                const startC = c - dc * i;

                if (startR < 0 || startR > BOARD_SIZE - 5 || startC < 0 || startC > BOARD_SIZE - 5) continue;
                
                let myStones = 0;
                let emptySpaces = 0;
                let isBlocked = false;

                // ìœˆë„ìš° 5ì¹¸ì„ í™•ì¸
                for (let j = 0; j < 5; j++) {
                    const cr = startR + dr * j;
                    const cc = startC + dc * j;

                    if (currentBoard[cr][cc] === player) {
                        myStones++;
                    } else if (currentBoard[cr][cc] === opponent) {
                        isBlocked = true;
                        break;
                    } else {
                        emptySpaces++;
                    }
                }
                
                if (!isBlocked) {
                    // 4ê°œ ì—°ì† (í•œ ìª½ì´ ë§‰íˆì§€ ì•Šì€ 4: ê°œë°© 4, ê°‡íŒ 4)
                    if (myStones === 4 && emptySpaces === 1) {
                         // ì–‘ìª½ ëì´ ëª¨ë‘ ë¹„ì–´ìˆë‹¤ë©´: ë§¤ìš° ë†’ì€ ì ìˆ˜ (í•„ìŠ¹)
                         const block1 = (startR - dr < 0 || startR - dr >= BOARD_SIZE || startC - dc < 0 || startC - dc >= BOARD_SIZE || currentBoard[startR - dr][startC - dc] === opponent);
                         const block2 = (startR + dr * 5 < 0 || startR + dr * 5 >= BOARD_SIZE || startC + dc * 5 < 0 || startC + dc * 5 >= BOARD_SIZE || currentBoard[startR + dr * 5][startC + dc * 5] === opponent);

                        if (!block1 && !block2) { // ì–‘ìª½ ì˜¤í”ˆ 4
                             score += 100000;
                        } else { // í•œìª½ ì˜¤í”ˆ 4 (ë§‰ì•„ì•¼ í•˜ëŠ” ìƒí™©)
                             score += 50000;
                        }
                    } 
                    // 3ê°œ ì—°ì†
                    else if (myStones === 3 && emptySpaces === 2) {
                         // ì–‘ìª½ ì˜¤í”ˆ 3 (ë§¤ìš° ìœ„í—˜í•œ ì‚¼ì‚¼)
                        const block1 = (startR - dr < 0 || startR - dr >= BOARD_SIZE || startC - dc < 0 || startC - dc >= BOARD_SIZE || currentBoard[startR - dr][startC - dc] === opponent);
                        const block2 = (startR + dr * 5 < 0 || startR + dr * 5 >= BOARD_SIZE || startC + dc * 5 < 0 || startC + dc * 5 >= BOARD_SIZE || currentBoard[startR + dr * 5][startC + dc * 5] === opponent);

                        if (!block1 && !block2) { 
                             score += 1000;
                        } else {
                             score += 100;
                        }
                    }
                    // 2ê°œ ì—°ì†
                    else if (myStones === 2 && emptySpaces === 3) {
                        score += 10;
                    }
                }
            }
            return score;
        }

        window.onload = startGame;
    </script>
</body>
</html>