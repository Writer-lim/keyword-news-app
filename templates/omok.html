<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ì˜¤ëª© ê²Œì„ (AI ê¸°ëŠ¥) ğŸ”´âš«</title>
    <style>
        body { font-family: Arial, sans-serif; display: flex; flex-direction: column; align-items: center; background-color: #f4f4f9; }
        .container { max-width: 600px; margin: 20px; padding: 20px; background: white; border-radius: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        h1 { text-align: center; color: #333; }
        #nav a { margin: 0 10px; text-decoration: none; color: #007bff; }
        
        #controls { margin-bottom: 20px; display: flex; flex-direction: column; align-items: center; }
        #controls button, #controls select { padding: 8px 15px; margin: 5px; cursor: pointer; border-radius: 4px; border: 1px solid #ddd; }
        #controls button.active { background-color: #007bff; color: white; border-color: #007bff; }
        
        #board-container { border: 1px solid #000; box-shadow: 0 0 10px rgba(0, 0, 0, 0.3); }
        #board {
            display: grid;
            grid-template-columns: repeat(15, 30px);
            grid-template-rows: repeat(15, 30px);
            background-color: #e3b772; /* ë‚˜ë¬´íŒ ìƒ‰ìƒ */
        }
        .cell {
            width: 30px;
            height: 30px;
            border: 1px solid #000;
            border-top: none; 
            border-left: none;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
        }
        /* ì¤‘ì•™ ì‹­ìê°€ë§Œ ë³´ì´ê²Œ ì„¤ì • */
        .cell:nth-child(15n + 1) { border-left: 1px solid #000; }
        .cell:nth-child(-n + 15) { border-top: 1px solid #000; }
        
        .stone {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            position: absolute;
        }
        .black { background-color: black; }
        .white { background-color: white; border: 1px solid #333; }
        #status { margin-top: 20px; font-size: 1.2em; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <div id="nav" style="text-align: center; margin-bottom: 20px;">
            <a href="/">ë‰´ìŠ¤ ê²€ìƒ‰ê¸°ë¡œ ëŒì•„ê°€ê¸°</a>
        </div>
        <h1>ì˜¤ëª© ê²Œì„ ğŸ”´âš«</h1>
        
        <div id="controls">
            <div style="margin-bottom: 10px;">
                <button id="mode-user-ai" data-mode="user-ai" class="active">ì‚¬ìš©ì vs AI</button>
                <button id="mode-ai-ai" data-mode="ai-ai">AI vs AI</button>
            </div>
            
            <div>
                <label for="difficulty">AI ë‚œì´ë„:</label>
                <select id="difficulty">
                    <option value="1">í•˜ìˆ˜</option>
                    <option value="2" selected>ì¤‘ìˆ˜</option>
                    <option value="3">ê³ ìˆ˜</option>
                </select>
                <button onclick="startGame()">ìƒˆ ê²Œì„ ì‹œì‘</button>
            </div>
        </div>

        <div id="board-container">
             <div id="board"></div>
        </div>
        
        <div id="status">ê²Œì„ì„ ì‹œì‘í•´ ì£¼ì„¸ìš”.</div>
    </div>

    <script>
        const boardElement = document.getElementById('board');
        const statusElement = document.getElementById('status');
        const difficultySelect = document.getElementById('difficulty');
        const modeButtons = document.querySelectorAll('#controls button[data-mode]');
        
        const BOARD_SIZE = 15;
        let board = [];
        let currentPlayer = 1; // 1: í‘(ì‚¬ìš©ì/ì„ ê³µ), 2: ë°±(AI/í›„ê³µ)
        let gameOver = false;
        let currentMode = 'user-ai';
        let aiDepth = 2; // ê¸°ë³¸ ì¤‘ìˆ˜

        // -- ì´ˆê¸°í™” ë° UI ë¡œì§ --

        function initializeBoard() {
            board = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(0));
            boardElement.innerHTML = '';
            
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    cell.addEventListener('click', handleMove);
                    boardElement.appendChild(cell);
                }
            }
            gameOver = false;
        }

        modeButtons.forEach(button => {
            button.addEventListener('click', () => {
                modeButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                currentMode = button.dataset.mode;
                startGame();
            });
        });

        difficultySelect.addEventListener('change', () => {
            aiDepth = parseInt(difficultySelect.value);
            // ë‚œì´ë„ë³„ íƒìƒ‰ ê¹Šì´ ì„¤ì • (ê°„ë‹¨í™”)
            // í•˜ìˆ˜: 1, ì¤‘ìˆ˜: 2, ê³ ìˆ˜: 3 (3 ì´ìƒì€ ë¸Œë¼ìš°ì € ë¶€í•˜ ì‹¬í•¨)
        });

        function startGame() {
            aiDepth = parseInt(difficultySelect.value);
            currentPlayer = 1; // í•­ìƒ í‘ëŒ(1)ë¶€í„° ì‹œì‘
            initializeBoard();
            statusElement.textContent = 'í‘ëŒ ì°¨ë¡€ì…ë‹ˆë‹¤.';
            
            if (currentMode === 'ai-ai') {
                runAIGame();
            } else if (currentMode === 'user-ai') {
                // ì‚¬ìš©ì vs AI ëª¨ë“œ (ì‚¬ìš©ì í„´ ëŒ€ê¸°)
                // ë§Œì•½ AIê°€ ì„ ê³µì„ í•œë‹¤ë©´ ì—¬ê¸°ì„œ makeAIMove() í˜¸ì¶œ
            }
        }

        // -- ê²Œì„ íë¦„ ì œì–´ ë¡œì§ --

        function handleMove(event) {
            if (gameOver || currentMode !== 'user-ai' || currentPlayer !== 1) return; // ì‚¬ìš©ì í„´ì´ ì•„ë‹ˆë©´ ë¬´ì‹œ

            const row = parseInt(event.target.dataset.row);
            const col = parseInt(event.target.dataset.col);

            if (board[row][col] === 0) {
                placeStone(row, col, 1);
                
                if (!gameOver) {
                    // AI í„´ìœ¼ë¡œ ì „í™˜
                    statusElement.textContent = 'ë°±ëŒ (AI)ì´ ìƒê° ì¤‘...';
                    setTimeout(makeAIMove, 500); // 0.5ì´ˆ ë”œë ˆì´ í›„ AI ì‹¤í–‰
                }
            }
        }

        function placeStone(r, c, player) {
            board[r][c] = player;
            drawStoneOnUI(r, c, player);
            
            if (checkWin(r, c, player)) {
                const winner = player === 1 ? 'í‘ëŒ' : 'ë°±ëŒ';
                statusElement.textContent = `${winner} ìŠ¹ë¦¬! ğŸ‰`;
                gameOver = true;
            } else {
                currentPlayer = player === 1 ? 2 : 1;
                if (currentMode !== 'ai-ai') {
                    const nextPlayer = currentPlayer === 1 ? 'í‘ëŒ' : 'ë°±ëŒ (AI)';
                    statusElement.textContent = `${nextPlayer} ì°¨ë¡€ì…ë‹ˆë‹¤.`;
                }
            }
        }
        
        function drawStoneOnUI(r, c, player) {
            const index = r * BOARD_SIZE + c;
            const cell = boardElement.children[index];
            if (cell.children.length > 0) return;

            const stone = document.createElement('div');
            stone.className = `stone ${player === 1 ? 'black' : 'white'}`;
            cell.appendChild(stone);
        }

        function runAIGame() {
            if (gameOver) return;

            // AI vs AI ëª¨ë“œ ì‹¤í–‰
            if (currentPlayer === 1) {
                statusElement.textContent = 'í‘ëŒ (AI)ì´ ìƒê° ì¤‘...';
            } else {
                statusElement.textContent = 'ë°±ëŒ (AI)ì´ ìƒê° ì¤‘...';
            }

            setTimeout(() => {
                makeAIMove(true);
                if (!gameOver) {
                    runAIGame(); // ë‹¤ìŒ í„´ ì¬ê·€ í˜¸ì¶œ
                }
            }, 500);
        }

        // -- AI ë¡œì§ --

        function makeAIMove(isAIVsAI = false) {
            if (gameOver) return;

            const aiPlayer = currentPlayer; // í˜„ì¬ í„´ í”Œë ˆì´ì–´
            const bestMove = findBestMove(aiPlayer, aiDepth);

            if (bestMove) {
                placeStone(bestMove.r, bestMove.c, aiPlayer);
            }
            
            // AI vs AI ëª¨ë“œì¼ ë•Œë§Œ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•˜ê³  ë‹¤ìŒ AI í„´ì„ ìœ„í•´ í”Œë ˆì´ì–´ ì „í™˜
            if (isAIVsAI && !gameOver) {
                 const nextPlayer = currentPlayer === 1 ? 'í‘ëŒ' : 'ë°±ëŒ';
                 statusElement.textContent = `${nextPlayer} ì°¨ë¡€ì…ë‹ˆë‹¤.`;
            }
        }

        // Minimax ì•Œê³ ë¦¬ì¦˜ (ê°„ë‹¨í™” ë° ì„±ëŠ¥ ìµœì í™”)
        function findBestMove(player, depth) {
            let bestScore = player === 1 ? -Infinity : Infinity;
            let bestMove = null;
            const maximizingPlayer = player === 1;

            const possibleMoves = getPossibleMoves();

            // Minimax íƒìƒ‰
            for (const move of possibleMoves) {
                const newBoard = simulateMove(board, move.r, move.c, player);
                const score = minimax(newBoard, depth - 1, -Infinity, Infinity, !maximizingPlayer, player);

                if (maximizingPlayer) {
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                } else {
                    if (score < bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                }
            }
            return bestMove;
        }

        // Minimax ì¬ê·€ í•¨ìˆ˜
        function minimax(currentBoard, depth, alpha, beta, maximizingPlayer, originalPlayer) {
            const winner = checkBoardWin(currentBoard);
            if (winner === originalPlayer) return 100000000 + depth; // ìŠ¹ë¦¬
            if (winner !== 0) return -100000000 - depth; // íŒ¨ë°°
            if (depth === 0) return evaluateBoard(currentBoard, originalPlayer); // ê¹Šì´ ë„ë‹¬

            const nextPlayer = maximizingPlayer ? originalPlayer : (originalPlayer === 1 ? 2 : 1);
            const possibleMoves = getPossibleMovesFromBoard(currentBoard);

            if (maximizingPlayer) {
                let maxEval = -Infinity;
                for (const move of possibleMoves) {
                    const newBoard = simulateMove(currentBoard, move.r, move.c, nextPlayer);
                    const eval = minimax(newBoard, depth - 1, alpha, beta, false, originalPlayer);
                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, maxEval);
                    if (beta <= alpha) break; // Alpha-Beta Pruning
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of possibleMoves) {
                    const newBoard = simulateMove(currentBoard, move.r, move.c, nextPlayer);
                    const eval = minimax(newBoard, depth - 1, alpha, beta, true, originalPlayer);
                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, minEval);
                    if (beta <= alpha) break; // Alpha-Beta Pruning
                }
                return minEval;
            }
        }

        // -- ë³´ì¡° í•¨ìˆ˜ --

        // í˜„ì¬ ìƒíƒœì—ì„œ ë†“ì„ ìˆ˜ ìˆëŠ” ëŒ ì£¼ë³€ 1ì¹¸ ë¹ˆ ê³µê°„ ëª©ë¡ ë°˜í™˜ (íƒìƒ‰ ìµœì í™”)
        function getPossibleMoves() {
            const moves = new Set();
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] !== 0) {
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                if (dr === 0 && dc === 0) continue;
                                const nr = r + dr;
                                const nc = c + dc;
                                if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === 0) {
                                    moves.add(`${nr},${nc}`);
                                }
                            }
                        }
                    }
                }
            }
            // ì•„ì§ ëŒì´ í•˜ë‚˜ë„ ì—†ì„ ê²½ìš° ì¤‘ì•™ì— ë†“ê¸°
            if (moves.size === 0) {
                 moves.add(`${Math.floor(BOARD_SIZE/2)},${Math.floor(BOARD_SIZE/2)}`);
            }
            return Array.from(moves).map(move => {
                const [r, c] = move.split(',').map(Number);
                return {r, c};
            });
        }
        
        function getPossibleMovesFromBoard(currentBoard) {
            const moves = new Set();
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (currentBoard[r][c] !== 0) {
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                if (dr === 0 && dc === 0) continue;
                                const nr = r + dr;
                                const nc = c + dc;
                                if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && currentBoard[nr][nc] === 0) {
                                    moves.add(`${nr},${nc}`);
                                }
                            }
                        }
                    }
                }
            }
            return Array.from(moves).map(move => {
                const [r, c] = move.split(',').map(Number);
                return {r, c};
            });
        }

        function simulateMove(currentBoard, r, c, player) {
            const newBoard = currentBoard.map(row => [...row]);
            newBoard[r][c] = player;
            return newBoard;
        }

        // ìŠ¹ë¦¬ ì¡°ê±´ í™•ì¸ (UIìš©)
        function checkWin(r, c, player) {
            // 8ë°©í–¥ ë²¡í„°: ìˆ˜í‰(0), ìˆ˜ì§(1), ëŒ€ê°ì„ (2, 3)
            const directions = [
                [0, 1], [1, 0], [1, 1], [1, -1] 
            ];

            for (const [dr, dc] of directions) {
                let count = 1;
                count += countLine(r, c, dr, dc, player);
                count += countLine(r, c, -dr, -dc, player);
                if (count >= 5) return true;
            }
            return false;
        }
        
        // ìŠ¹ë¦¬ ì¡°ê±´ í™•ì¸ (AI íƒìƒ‰ìš©)
        function checkBoardWin(currentBoard) {
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (currentBoard[r][c] !== 0) {
                        const player = currentBoard[r][c];
                        const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
                        
                        for (const [dr, dc] of directions) {
                             // 5ì¹¸ ì—°ì† í™•ì¸
                            for (let i = 0; i < 5; i++) {
                                const nr = r + dr * i;
                                const nc = c + dc * i;
                                if (nr < 0 || nr >= BOARD_SIZE || nc < 0 || nc >= BOARD_SIZE || currentBoard[nr][nc] !== player) break;
                                if (i === 4) return player; // 5ëª© ë‹¬ì„±
                            }
                        }
                    }
                }
            }
            return 0; // ìŠ¹ì ì—†ìŒ
        }

        function countLine(r, c, dr, dc, player) {
            let count = 0;
            for (let i = 1; i < 5; i++) {
                const nr = r + dr * i;
                const nc = c + dc * i;

                if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === player) {
                    count++;
                } else {
                    break;
                }
            }
            return count;
        }

        // ë³´ë“œ í‰ê°€ í•¨ìˆ˜ (AI ë‚œì´ë„ì˜ í•µì‹¬)
        function evaluateBoard(currentBoard, player) {
            // ê°„ë‹¨í•˜ê²Œ 4ê°œ, 3ê°œ, 2ê°œ ì—°ì† ëŒì˜ ê°œìˆ˜ë¥¼ ì„¸ì–´ ì ìˆ˜ ë¶€ì—¬
            // ì‹¤ì œ Minimax ì˜¤ëª©ì€ ì´ ë¶€ë¶„ì´ ë§¤ìš° ë³µì¡í•©ë‹ˆë‹¤. ì—¬ê¸°ì„œëŠ” ê¸°ëŠ¥ êµ¬í˜„ì„ ìœ„í•´ ê°„ë‹¨í™”
            let score = 0;
            const opponent = player === 1 ? 2 : 1;
            
            // ìŠ¹ë¦¬/íŒ¨ë°°ëŠ” ì´ë¯¸ minimax ìƒë‹¨ì—ì„œ ì²´í¬í–ˆìœ¼ë¯€ë¡œ, ì—¬ê¸°ì„œëŠ” ìœ ë¦¬í•¨ì„ í‰ê°€
            score += evaluateLinePatterns(currentBoard, player) * 1;
            score -= evaluateLinePatterns(currentBoard, opponent) * 1.5; // ìƒëŒ€ë°© ê³µê²©ì„ ë” ì¤‘ìš”í•˜ê²Œ í‰ê°€

            return score;
        }
        
        // 5ì¤„ íŒ¨í„´ í‰ê°€
        function evaluateLinePatterns(currentBoard, player) {
            let score = 0;
            const patterns = {
                5: 1000000, // 5ê°œ ì—°ì† (ê±°ì˜ ìŠ¹ë¦¬)
                4: 10000,   // 4ê°œ ì—°ì†
                3: 100,     // 3ê°œ ì—°ì†
                2: 10,      // 2ê°œ ì—°ì†
            };

            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    for (const [dr, dc] of directions) {
                        for (let length = 2; length <= 4; length++) {
                            let count = 0;
                            let empty = 0;
                            
                            for (let i = 0; i < 5; i++) {
                                const nr = r + dr * i;
                                const nc = c + dc * i;

                                if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                                    if (currentBoard[nr][nc] === player) {
                                        count++;
                                    } else if (currentBoard[nr][nc] === 0) {
                                        empty++;
                                    } else {
                                        // ìƒëŒ€ ëŒì´ ë§‰ê³  ìˆìŒ
                                        count = 0; 
                                        break;
                                    }
                                } else {
                                    // ë³´ë“œ ë°–
                                    count = 0;
                                    break;
                                }
                            }

                            if (count === length && empty > 0) {
                                score += patterns[length];
                            }
                        }
                    }
                }
            }
            return score;
        }


        // í˜ì´ì§€ ë¡œë“œ ì‹œ ê²Œì„ ì´ˆê¸°í™”
        window.onload = startGame;
    </script>
</body>
</html>