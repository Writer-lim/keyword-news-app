<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìŠˆí¼ ìŠ¤ë¬´ë”” (ê³¼ì¼ í•©ì¹˜ê¸° ê²Œì„)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');
        
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #f3f4f6;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #game-container {
            position: relative;
            width: 400px; /* ê²Œì„ ë³´ë“œì˜ ë„ˆë¹„ */
            background-color: #ffffff;
            border: 4px solid #10b981; /* ì—ë©”ë„ë“œ 500 */
            border-radius: 12px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }

        #score-board {
            padding: 15px;
            background-color: #059669; /* ì—ë©”ë„ë“œ 600 */
            color: white;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.2rem;
            font-weight: bold;
        }

        /* Matter.js ìº”ë²„ìŠ¤ëŠ” ì—¬ê¸°ì— ë Œë”ë§ë©ë‹ˆë‹¤ */
        #game-canvas {
            display: block;
            margin: 0 auto;
        }

        /* ê³¼ì¼ ìŠ¤íƒ€ì¼ë§ */
        .fruit {
            position: absolute;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: 900;
            color: #fff;
            user-select: none;
            /* Matter.jsê°€ ìœ„ì¹˜ì™€ í¬ê¸°ë¥¼ ê´€ë¦¬í•˜ì§€ë§Œ, ì´ˆê¸° ìŠ¤íƒ€ì¼ ì •ì˜ */
        }

        /* ê²Œì„ ì˜¤ë²„ ì˜¤ë²„ë ˆì´ */
        #game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            display: none; /* ì´ˆê¸°ì—ëŠ” ìˆ¨ê¹€ */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            border-radius: 8px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="score-board">
            <span>ì ìˆ˜: <span id="score">0</span></span>
            <button onclick="startGame()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-1 px-3 rounded text-sm transition-colors">
                ìƒˆ ê²Œì„
            </button>
        </div>

        <div id="game-canvas">
            </div>

        <div id="game-over-overlay">
            <h2 class="text-3xl font-bold text-gray-800 mb-3">ê²Œì„ ì˜¤ë²„!</h2>
            <p class="text-lg text-gray-600 mb-6">ìµœì¢… ì ìˆ˜: <span id="final-score" class="font-extrabold text-red-600">0</span></p>
            <button onclick="startGame()" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded transition-colors">
                ë‹¤ì‹œ ì‹œì‘
            </button>
        </div>
    </div>

    <script>
        // --- Matter.js ì´ˆê¸°í™” ---
        const { Engine, Render, World, Bodies, Events } = Matter;

        const GAME_WIDTH = 400;
        const GAME_HEIGHT = 600;
        const WALL_THICKNESS = 20;
        const CONTAINER_ID = 'game-canvas';

        let engine;
        let world;
        let render;
        let score = 0;
        let currentFruit = null;
        let fruits = []; // í˜„ì¬ ê²Œì„ì— ìˆëŠ” ëª¨ë“  ê³¼ì¼ ê°ì²´

        // ê³¼ì¼ í¬ê¸°ì™€ ìƒ‰ìƒ ì •ì˜ (1~11ë‹¨ê³„)
        const FRUITS_DATA = [
            { name: 'ì²´ë¦¬', radius: 15, color: '#f87171', emoji: 'ğŸ’' },    // 1
            { name: 'ë”¸ê¸°', radius: 20, color: '#f43f5e', emoji: 'ğŸ“' },    // 2
            { name: 'í¬ë„', radius: 25, color: '#c084fc', emoji: 'ğŸ‡' },    // 3
            { name: 'ê°ê·¤', radius: 30, color: '#fb923c', emoji: 'ğŸŠ' },    // 4
            { name: 'ë ˆëª¬', radius: 35, color: '#fde047', emoji: 'ğŸ‹' },    // 5
            { name: 'í‚¤ìœ„', radius: 40, color: '#84cc16', emoji: 'ğŸ¥' },    // 6
            { name: 'í† ë§ˆí† ', radius: 45, color: '#ef4444', emoji: 'ğŸ…' },  // 7
            { name: 'ë³µìˆ­ì•„', radius: 50, color: '#fcd34d', emoji: 'ğŸ‘' },  // 8
            { name: 'íŒŒì¸ì• í”Œ', radius: 55, color: '#f59e0b', emoji: 'ğŸ' },// 9
            { name: 'ë©œë¡ ', radius: 60, color: '#4ade80', emoji: 'ğŸˆ' },    // 10
            { name: 'ìˆ˜ë°•', radius: 65, color: '#22c55e', emoji: 'ğŸ‰' }     // 11
        ];

        // --- 1. ê²Œì„ í™˜ê²½ ì„¤ì • ë° ì´ˆê¸°í™” ---

        function setupEngine() {
            engine = Engine.create();
            world = engine.world;
            world.gravity.y = 1; // ê¸°ë³¸ ì¤‘ë ¥ ì„¤ì •

            render = Render.create({
                element: document.getElementById(CONTAINER_ID),
                engine: engine,
                options: {
                    width: GAME_WIDTH,
                    height: GAME_HEIGHT,
                    wireframes: false, // ì™€ì´ì–´í”„ë ˆì„ ëŒ€ì‹  ì‹¤ì œ ë Œë”ë§ ì‚¬ìš©
                    background: '#e0f2f1' // ë¯¼íŠ¸ ë°°ê²½
                }
            });

            Render.run(render);
            Engine.run(engine);
        }

        function createBoundaries() {
            // ë°”ë‹¥ (Floor)
            const floor = Bodies.rectangle(GAME_WIDTH / 2, GAME_HEIGHT + WALL_THICKNESS / 2, GAME_WIDTH, WALL_THICKNESS, { 
                isStatic: true, 
                label: 'floor',
                render: { fillStyle: '#4b5563' }
            });
            // ì™¼ìª½ ë²½ (Left Wall)
            const leftWall = Bodies.rectangle(-WALL_THICKNESS / 2, GAME_HEIGHT / 2, WALL_THICKNESS, GAME_HEIGHT, { 
                isStatic: true, 
                label: 'wall',
                render: { fillStyle: '#4b5563' }
            });
            // ì˜¤ë¥¸ìª½ ë²½ (Right Wall)
            const rightWall = Bodies.rectangle(GAME_WIDTH + WALL_THICKNESS / 2, GAME_HEIGHT / 2, WALL_THICKNESS, GAME_HEIGHT, { 
                isStatic: true, 
                label: 'wall',
                render: { fillStyle: '#4b5563' }
            });

            World.add(world, [floor, leftWall, rightWall]);
        }

        function startGame() {
            if (engine) {
                World.clear(world, false);
                Engine.clear(engine);
                Render.stop(render);
                // ê¸°ì¡´ ìº”ë²„ìŠ¤ ì •ë¦¬
                const canvasElement = document.querySelector(`#${CONTAINER_ID} canvas`);
                if (canvasElement) canvasElement.remove();
            }

            setupEngine();
            createBoundaries();
            fruits = [];
            score = 0;
            document.getElementById('score').textContent = score;
            document.getElementById('game-over-overlay').style.display = 'none';

            // 0.5ì´ˆ í›„ ì²« ê³¼ì¼ ìƒì„±
            setTimeout(spawnNextFruit, 500); 
        }

        // --- 2. ê³¼ì¼ ìƒì„± ë° ë Œë”ë§ ---

        function getRandomFruitIndex() {
            // ì´ˆê¸°ì—ëŠ” 0ë²ˆ(ì²´ë¦¬)ë¶€í„° 4ë²ˆ(ë ˆëª¬)ê¹Œì§€ë§Œ ëœë¤í•˜ê²Œ ë‚˜ì˜¤ë„ë¡ ì œí•œ
            return Math.floor(Math.random() * 5); 
        }

        function spawnNextFruit() {
            if (currentFruit) return;

            const fruitIndex = getRandomFruitIndex();
            const fruitData = FRUITS_DATA[fruitIndex];
            const radius = fruitData.radius;
            
            // ê³¼ì¼ ìƒì„± ìœ„ì¹˜ (ë³´ë“œ ì¤‘ì•™ ìƒë‹¨)
            const x = GAME_WIDTH / 2;
            const y = radius;

            const newFruit = Bodies.circle(x, y, radius, {
                label: `fruit-${fruitIndex}`,
                restitution: 0.1, // ë°˜ë°œ ê³„ìˆ˜ (ì•½ê°„ íŠ•ê¹€)
                friction: 0.1,    // ë§ˆì°° ê³„ìˆ˜ (ì•½ê°„ êµ´ëŸ¬ë‹¤ë‹˜)
                density: 0.001,   // ë°€ë„
                isSleeping: true, // ì´ˆê¸°ì—ëŠ” ì •ì§€ ìƒíƒœ
                render: {
                    fillStyle: fruitData.color
                },
                fruitIndex: fruitIndex // ì‚¬ìš©ì ì •ì˜ ì†ì„± ì¶”ê°€
            });
            
            // ê³¼ì¼ ë Œë”ë§ì„ ìœ„í•œ HTML ìš”ì†Œ ìƒì„± ë° ë§¤í•‘ (Matter.js ë Œë”ë§ ìœ„ì— ê²¹ì¹˜ê¸°)
            const fruitDiv = document.createElement('div');
            fruitDiv.classList.add('fruit');
            fruitDiv.innerHTML = fruitData.emoji;
            fruitDiv.style.width = fruitDiv.style.height = `${radius * 2}px`;
            fruitDiv.style.fontSize = `${radius * 0.8}px`;
            fruitDiv.style.backgroundColor = fruitData.color;
            fruitDiv.style.zIndex = 50;
            
            newFruit.div = fruitDiv; // Matter ë°”ë””ì™€ divë¥¼ ì—°ê²°
            document.getElementById(CONTAINER_ID).appendChild(fruitDiv);

            currentFruit = newFruit;
            World.add(world, currentFruit);
        }

        // Matter.js ë Œë”ë§ ì—…ë°ì´íŠ¸ ì‹œ HTML ìš”ì†Œ ìœ„ì¹˜ ë™ê¸°í™”
        Events.on(engine, 'beforeUpdate', () => {
            fruits.forEach(fruit => {
                if (fruit.div) {
                    // Matter ì¢Œí‘œë¥¼ HTML ìœ„ì¹˜ë¡œ ë³€í™˜
                    fruit.div.style.left = `${fruit.position.x - fruit.circleRadius}px`;
                    fruit.div.style.top = `${fruit.position.y - fruit.circleRadius}px`;
                }
            });
            
            // í˜„ì¬ ë–¨ì–´ëœ¨ë¦´ ê³¼ì¼ì€ ë§ˆìš°ìŠ¤ ìœ„ì¹˜ë¥¼ ë”°ë¼ë‹¤ë‹ˆë„ë¡ ì²˜ë¦¬
            if (currentFruit && currentFruit.isSleeping) {
                 if (currentFruit.div) {
                    currentFruit.div.style.left = `${currentFruit.position.x - currentFruit.circleRadius}px`;
                    currentFruit.div.style.top = `${currentFruit.position.y - currentFruit.circleRadius}px`;
                }
            }
        });

        // --- 3. ì‚¬ìš©ì ì…ë ¥ ì²˜ë¦¬ (ë–¨ì–´ëœ¨ë¦¬ê¸°) ---
        
        // ë§ˆìš°ìŠ¤ ì´ë™ ì‹œ í˜„ì¬ ê³¼ì¼ì˜ x ìœ„ì¹˜ ì—…ë°ì´íŠ¸
        document.getElementById(CONTAINER_ID).addEventListener('mousemove', (e) => {
            if (currentFruit && currentFruit.isSleeping) {
                const rect = e.currentTarget.getBoundingClientRect();
                let x = e.clientX - rect.left;
                
                // ê²½ê³„ ë‚´ ì œí•œ
                const minX = currentFruit.circleRadius + WALL_THICKNESS;
                const maxX = GAME_WIDTH - currentFruit.circleRadius - WALL_THICKNESS;
                
                x = Math.max(minX, Math.min(maxX, x));
                
                // Matter ë°”ë””ì˜ ìœ„ì¹˜ë§Œ ì—…ë°ì´íŠ¸
                Matter.Body.setPosition(currentFruit, { x: x, y: currentFruit.position.y });
            }
        });
        
        // í´ë¦­ ì‹œ ê³¼ì¼ ë–¨ì–´ëœ¨ë¦¬ê¸°
        document.getElementById(CONTAINER_ID).addEventListener('click', () => {
            if (currentFruit && currentFruit.isSleeping) {
                Matter.Body.setSleep(currentFruit, false); // ì ìê¸° ìƒíƒœ í•´ì œ (ì¤‘ë ¥ ì ìš© ì‹œì‘)
                fruits.push(currentFruit);
                currentFruit = null;

                // ë‹¤ìŒ ê³¼ì¼ ìƒì„±ì€ ì ì‹œ ì§€ì—° í›„ ì‹¤í–‰
                setTimeout(spawnNextFruit, 1000); 
            }
        });

        // --- 4. ì¶©ëŒ ê°ì§€ ë° í•©ì¹˜ê¸° ë¡œì§ ---

        Events.on(engine, 'collisionStart', (event) => {
            const pairs = event.pairs;

            pairs.forEach(pair => {
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;

                // ë‘ ê³¼ì¼ì´ ëª¨ë‘ ê³¼ì¼ì¸ì§€ í™•ì¸
                const isFruitA = bodyA.label.startsWith('fruit');
                const isFruitB = bodyB.label.startsWith('fruit');
                
                if (isFruitA && isFruitB) {
                    const fruitIndexA = bodyA.fruitIndex;
                    const fruitIndexB = bodyB.fruitIndex;
                    
                    // ê°™ì€ ì¢…ë¥˜ì˜ ê³¼ì¼ì¸ì§€ í™•ì¸
                    if (fruitIndexA === fruitIndexB) {
                        // í•©ì¹˜ê¸° ì²˜ë¦¬ (ë” ì´ìƒ ì›€ì§ì´ì§€ ì•ŠëŠ” ê²½ìš°ì—ë§Œ í•©ì¹˜ë„ë¡ ì²˜ë¦¬í•˜ëŠ” ê²ƒì´ ì¢‹ìœ¼ë‚˜, ì¼ë‹¨ ë‹¨ìˆœí™”)
                        
                        // ì´ë¯¸ í•©ì³ì§„ ìƒíƒœë¼ë©´ ë¬´ì‹œ
                        if (bodyA.isMerging || bodyB.isMerging) return;
                        
                        // í•©ì³ì§€ëŠ” ê³¼ì¼ í‘œì‹œ
                        bodyA.isMerging = true;
                        bodyB.isMerging = true;

                        // 1. ê¸°ì¡´ ê³¼ì¼ ì œê±°
                        World.remove(world, [bodyA, bodyB]);
                        
                        // 2. HTML ìš”ì†Œ ì œê±°
                        if (bodyA.div) bodyA.div.remove();
                        if (bodyB.div) bodyB.div.remove();

                        // 3. ë°°ì—´ì—ì„œ ì œê±°
                        fruits = fruits.filter(f => f !== bodyA && f !== bodyB);

                        // 4. ìƒˆ ê³¼ì¼ ìƒì„±
                        const newIndex = fruitIndexA + 1;
                        if (newIndex < FRUITS_DATA.length) {
                            const newFruitData = FRUITS_DATA[newIndex];
                            const avgX = (bodyA.position.x + bodyB.position.x) / 2;
                            const avgY = (bodyA.position.y + bodyB.position.y) / 2;

                            const mergedFruit = Bodies.circle(avgX, avgY, newFruitData.radius, {
                                label: `fruit-${newIndex}`,
                                restitution: 0.1,
                                friction: 0.1,
                                density: 0.001,
                                fruitIndex: newIndex,
                                render: { fillStyle: newFruitData.color }
                            });
                            
                            // HTML ìš”ì†Œ ìƒì„±
                            const newFruitDiv = document.createElement('div');
                            newFruitDiv.classList.add('fruit');
                            newFruitDiv.innerHTML = newFruitData.emoji;
                            newFruitDiv.style.width = newFruitDiv.style.height = `${newFruitData.radius * 2}px`;
                            newFruitDiv.style.fontSize = `${newFruitData.radius * 0.8}px`;
                            newFruitDiv.style.backgroundColor = newFruitData.color;
                            newFruitDiv.style.zIndex = 50;
                            
                            mergedFruit.div = newFruitDiv;
                            document.getElementById(CONTAINER_ID).appendChild(newFruitDiv);

                            World.add(world, mergedFruit);
                            fruits.push(mergedFruit);

                            // ì ìˆ˜ ì—…ë°ì´íŠ¸ (ë‹¨ê³„ * 100ì )
                            score += (newIndex + 1) * 100; 
                            document.getElementById('score').textContent = score;
                        }
                    }
                }
            });
        });

        // --- 5. ê²Œì„ ì˜¤ë²„ ì¡°ê±´ ---
        
        Events.on(engine, 'beforeUpdate', () => {
            // ê²Œì„ ì˜¤ë²„ ì¡°ê±´: ê³¼ì¼ì´ íŠ¹ì • ë†’ì´ (ì˜ˆ: ë³´ë“œ ìƒë‹¨ 100px)ë¥¼ ë„˜ì–´ê°€ì„œ 1ì´ˆ ì´ìƒ ë¨¸ë¬´ë¥¼ ê²½ìš°
            const gameOverLine = 100; 

            fruits.forEach(fruit => {
                if (fruit.position.y < gameOverLine && fruit.velocity.y < 0.1) {
                    // TODO: íƒ€ì´ë¨¸ë¥¼ ì„¤ì •í•˜ì—¬ ì¼ì • ì‹œê°„ ë™ì•ˆ ìœ„ì— ë¨¸ë¬¼ë €ëŠ”ì§€ í™•ì¸í•˜ëŠ” ë¡œì§ ì¶”ê°€ í•„ìš”
                    // ì§€ê¸ˆì€ ë‹¨ìˆœí™”ë¥¼ ìœ„í•´ ì„ì‹œ ì£¼ì„ ì²˜ë¦¬
                    /*
                    if (!fruit.isAboveLineTimer) {
                         fruit.isAboveLineTimer = setTimeout(() => {
                             if (fruit.position.y < gameOverLine) {
                                 // gameOver();
                             }
                         }, 1000);
                    }
                    */
                } else {
                    // clearTimeout(fruit.isAboveLineTimer);
                    // fruit.isAboveLineTimer = null;
                }
            });
        });


        function gameOver() {
            // ì—”ì§„ ì¤‘ì§€
            Render.stop(render);
            Engine.stop(engine);
            
            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over-overlay').style.display = 'flex';
        }

        // --- ì´ˆê¸° ì‹œì‘ ---
        document.addEventListener('DOMContentLoaded', () => {
            // DOM ë¡œë“œ í›„ ê²Œì„ ì‹œì‘
            startGame(); 
        });

    </script>
</body>
</html>