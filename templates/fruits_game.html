<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìŠˆí¼ ìŠ¤ë¬´ë”” (ê³¼ì¼ í•©ì¹˜ê¸° ê²Œì„)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');
        
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #f3f4f6;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
        }

        #game-container {
            position: relative;
            width: 400px; /* ê²Œì„ ë³´ë“œì˜ ë„ˆë¹„ */
            height: 650px; /* (50px ì ìˆ˜íŒ + 600px ë¬¼ë¦¬ ì˜ì—­) */
            background-color: #ffffff;
            border: 4px solid #10b981; 
            border-radius: 12px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            overflow: hidden; 
        }

        #score-board {
            position: absolute; /* ì ˆëŒ€ ìœ„ì¹˜ ì§€ì • */
            top: 0;
            left: 0;
            width: 100%;
            height: 50px; /* ì ìˆ˜íŒ ë†’ì´ ê³ ì • */
            z-index: 200; 
            padding: 10px 15px;
            background-color: #059669; 
            color: white;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.2rem;
            font-weight: bold;
        }

        /* Matter.js ìº”ë²„ìŠ¤ë¥¼ ì»¨í…Œì´ë„ˆì˜ ë¬¼ë¦¬ ì˜ì—­ ì‹œì‘ì (Y=50)ì— ë§ì¶¤ */
        #game-canvas {
            position: absolute;
            top: 50px; /* ì ìˆ˜íŒ ë†’ì´ë§Œí¼ ì•„ë˜ë¡œ ì˜¤í”„ì…‹ */
            left: 0;
            width: 400px;
            height: 600px;
        }
        
        /* Matter.jsê°€ ìƒì„±í•˜ëŠ” ìº”ë²„ìŠ¤ ìì²´ëŠ” ë¶€ëª¨(#game-canvas)ì— ê½‰ ì°¨ë„ë¡ ì„¤ì • */
        #game-canvas canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            cursor: pointer; 
        }

        /* ê³¼ì¼ ìŠ¤íƒ€ì¼ë§ */
        .fruit {
            position: absolute;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: 900;
            color: #fff;
            user-select: none;
            /* Matter.js ë°”ë””ì˜ ì¤‘ì•™ì— ë§ì¶”ê¸° ìœ„í•´ transform: translate(-50%, -50%) ì‚¬ìš© */
            transform: translate(-50%, -50%); 
            z-index: 100; 
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); 
            line-height: 1; /* ì´ëª¨ì§€ ë†’ì´ ë§ì¶”ê¸° */
        }

        /* ê²Œì„ ì˜¤ë²„ ì˜¤ë²„ë ˆì´ */
        #game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            border-radius: 8px;
            z-index: 300;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="score-board">
            <span>ì ìˆ˜: <span id="score">0</span></span>
            <button onclick="startGame()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-1 px-3 rounded text-sm transition-colors">
                ìƒˆ ê²Œì„
            </button>
        </div>

        <div id="game-canvas">
            </div>

        <div id="game-over-overlay">
            <h2 class="text-3xl font-bold text-gray-800 mb-3">ê²Œì„ ì˜¤ë²„!</h2>
            <p class="text-lg text-gray-600 mb-6">ìµœì¢… ì ìˆ˜: <span id="final-score" class="font-extrabold text-red-600">0</span></p>
            <button onclick="startGame()" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded transition-colors">
                ë‹¤ì‹œ ì‹œì‘
            </button>
        </div>
    </div>

    <script>
        // --- Matter.js ì´ˆê¸°í™” ---
        const { Engine, Render, World, Bodies, Events, Body, Runner } = Matter; 

        const GAME_WIDTH = 400; // ìº”ë²„ìŠ¤ ë„ˆë¹„
        const GAME_HEIGHT = 600; // ìº”ë²„ìŠ¤ ë†’ì´ (ì ìˆ˜íŒ ì•„ë˜ ë¬¼ë¦¬ ì˜ì—­)
        const WALL_THICKNESS = 20;
        const CANVAS_CONTAINER_ID = 'game-canvas';
        const GAME_CONTAINER_ID = 'game-container'; // ì´ë²¤íŠ¸ ë°”ì¸ë”© ëŒ€ìƒ

        let engine;
        let world;
        let render;
        let runner; 
        let score = 0;
        let currentFruit = null;
        let fruits = []; 
        let isDropping = false; 

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë¥¼ ë°”ì¸ë”©í•  ìƒìœ„ ì»¨í…Œì´ë„ˆ ìš”ì†Œ
        let gameContainerElement = null; 

        // ê³¼ì¼ ë°ì´í„° (ë°˜ì§€ë¦„ê³¼ ì´ëª¨ì§€ ì •ì˜)
        const FRUITS_DATA = [
            { name: 'ì²´ë¦¬', radius: 15, color: '#f87171', emoji: 'ğŸ’' },    // 1
            { name: 'ë”¸ê¸°', radius: 20, color: '#f43f5e', emoji: 'ğŸ“' },    // 2
            { name: 'í¬ë„', radius: 25, color: '#c084fc', emoji: 'ğŸ‡' },    // 3
            { name: 'ê°ê·¤', radius: 30, color: '#fb923c', emoji: 'ğŸŠ' },    // 4
            { name: 'ë ˆëª¬', radius: 35, color: '#fde047', emoji: 'ğŸ‹' },    // 5
            { name: 'í‚¤ìœ„', radius: 40, color: '#84cc16', emoji: 'ğŸ¥' },    // 6
            { name: 'í† ë§ˆí† ', radius: 45, color: '#ef4444', emoji: 'ğŸ…' },  // 7
            { name: 'ë³µìˆ­ì•„', radius: 50, color: '#fcd34d', emoji: 'ğŸ‘' },  // 8
            { name: 'íŒŒì¸ì• í”Œ', radius: 55, color: '#f59e0b', emoji: 'ğŸ' },// 9
            { name: 'ë©œë¡ ', radius: 60, color: '#4ade80', emoji: 'ğŸˆ' },    // 10
            { name: 'ìˆ˜ë°•', radius: 65, color: '#22c55e', emoji: 'ğŸ‰' }     // 11
        ];
        
        // ì ìˆ˜íŒ ë†’ì´ (Matter.js ì¢Œí‘œê³„ì— ì˜í–¥ X, CSS/ì´ë²¤íŠ¸ ì¢Œí‘œì—ë§Œ ì˜í–¥)
        const SCORE_BOARD_HEIGHT = 50; 


        // --- 1. ê²Œì„ í™˜ê²½ ì„¤ì • ë° ì´ˆê¸°í™” ---

        function setupEngine() {
            engine = Engine.create();
            world = engine.world;
            world.gravity.y = 1; 

            const canvasContainer = document.getElementById(CANVAS_CONTAINER_ID);

            render = Render.create({
                element: canvasContainer,
                engine: engine,
                options: {
                    width: GAME_WIDTH,
                    height: GAME_HEIGHT,
                    wireframes: false, 
                    background: '#e0f2f1', 
                    showInternalEdges: false,
                    showVelocity: false,
                    showCollisions: false
                }
            });

            runner = Runner.create();
            Runner.run(runner, engine); 
            Render.run(render);

            // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
            gameContainerElement = document.getElementById(GAME_CONTAINER_ID);
            if (gameContainerElement) {
                setupInputListeners(gameContainerElement); 
            }
        }

        function createBoundaries() {
            // ë°”ë‹¥ (Floor): ìº”ë²„ìŠ¤ ë†’ì´ (600)ì˜ ë§¨ ì•„ë˜
            const floor = Bodies.rectangle(GAME_WIDTH / 2, GAME_HEIGHT + WALL_THICKNESS / 2, GAME_WIDTH, WALL_THICKNESS, { 
                isStatic: true, 
                label: 'floor',
                render: { fillStyle: '#4b5563' }
            });
            // ì™¼ìª½ ë²½ (Left Wall)
            const leftWall = Bodies.rectangle(-WALL_THICKNESS / 2, GAME_HEIGHT / 2, WALL_THICKNESS, GAME_HEIGHT + 2 * WALL_THICKNESS, { 
                isStatic: true, 
                label: 'wall',
                render: { fillStyle: '#4b5563' }
            });
            // ì˜¤ë¥¸ìª½ ë²½ (Right Wall)
            const rightWall = Bodies.rectangle(GAME_WIDTH + WALL_THICKNESS / 2, GAME_HEIGHT / 2, WALL_THICKNESS, GAME_HEIGHT + 2 * WALL_THICKNESS, { 
                isStatic: true, 
                label: 'wall',
                render: { fillStyle: '#4b5563' }
            });

            World.add(world, [floor, leftWall, rightWall]);
        }

        function startGame() {
            // ê¸°ì¡´ ì—”ì§„ ì¤‘ì§€ ë° ì •ë¦¬
            if (runner) Runner.stop(runner); 
            if (render) Render.stop(render); 
            if (world) World.clear(world, true); 
            if (engine) Engine.clear(engine); 
            
            // ê¸°ì¡´ ìº”ë²„ìŠ¤ ë° ëª¨ë“  ê³¼ì¼ div ìš”ì†Œ ì •ë¦¬
            const canvasContainer = document.getElementById(CANVAS_CONTAINER_ID);
            canvasContainer.innerHTML = ''; 
            
            // ê¸°ì¡´ ë¦¬ìŠ¤ë„ˆ ì œê±° (ì¤‘ë³µ ë°©ì§€)
            if (gameContainerElement) {
                gameContainerElement.removeEventListener('mousemove', handleMouseMove);
                gameContainerElement.removeEventListener('click', handleClick);
                gameContainerElement = null;
            }

            setupEngine();
            createBoundaries();
            fruits = [];
            score = 0;
            isDropping = false;
            document.getElementById('score').textContent = score;
            document.getElementById('game-over-overlay').style.display = 'none';

            setTimeout(spawnNextFruit, 500); 
        }

        // --- 2. ê³¼ì¼ ìƒì„± ë° ë Œë”ë§ ---

        function getRandomFruitIndex() {
            return Math.floor(Math.random() * 5); 
        }

        function spawnNextFruit() {
            if (currentFruit || isDropping) return;

            const fruitIndex = getRandomFruitIndex();
            const fruitData = FRUITS_DATA[fruitIndex];
            const radius = fruitData.radius; 
            
            // Matter.js ìº”ë²„ìŠ¤ ì¤‘ì•™ ìƒë‹¨ (0, 0) ê¸°ì¤€
            const x = GAME_WIDTH / 2;
            const y = radius; 

            const newFruit = Bodies.circle(x, y, radius, {
                label: `fruit-${fruitIndex}`,
                restitution: 0.1, 
                friction: 0.1,    
                density: 0.001,   
                isSleeping: true, 
                isSensor: true,   
                render: { visible: false },
                fruitIndex: fruitIndex 
            });
            
            newFruit.radius = radius; 
            
            const fruitDiv = document.createElement('div');
            fruitDiv.classList.add('fruit');
            fruitDiv.innerHTML = fruitData.emoji;
            fruitDiv.style.width = fruitDiv.style.height = `${radius * 2}px`;
            // í°íŠ¸ í¬ê¸°ë¥¼ ë°˜ì§€ë¦„ì˜ 1.8ë°°ë¡œ í¬ê²Œ ì„¤ì •
            fruitDiv.style.fontSize = `${radius * 1.8}px`; 
            fruitDiv.style.backgroundColor = fruitData.color;
            
            newFruit.div = fruitDiv; 
            document.getElementById(CANVAS_CONTAINER_ID).appendChild(fruitDiv);

            currentFruit = newFruit;
            World.add(world, currentFruit);
        }

        // Matter.js ë Œë”ë§ ì—…ë°ì´íŠ¸ ì‹œ HTML ìš”ì†Œ ìœ„ì¹˜ ë™ê¸°í™”
        Events.on(engine, 'beforeUpdate', () => {
            // ë–¨ì–´ì§„ ê³¼ì¼ë“¤ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            fruits.forEach(fruit => {
                if (fruit.div) {
                    fruit.div.style.left = `${fruit.position.x}px`;
                    fruit.div.style.top = `${fruit.position.y}px`;
                }
            });
            
            // í˜„ì¬ ë–¨ì–´ëœ¨ë¦´ ê³¼ì¼ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (ë§ˆìš°ìŠ¤ë¥¼ ë”°ë¼ë‹¤ë‹˜)
            if (currentFruit && currentFruit.isSleeping) {
                 if (currentFruit.div) {
                    currentFruit.div.style.left = `${currentFruit.position.x}px`;
                    currentFruit.div.style.top = `${currentFruit.position.y}px`;
                }
            }
        });

        // --- 3. ì‚¬ìš©ì ì…ë ¥ ì²˜ë¦¬ (ë–¨ì–´ëœ¨ë¦¬ê¸°) ---
        
        // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ í•¨ìˆ˜ ë¶„ë¦¬
        function handleMouseMove(e) {
            if (currentFruit && currentFruit.isSleeping && !isDropping) {
                // game-containerë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìƒëŒ€ ìœ„ì¹˜ ê³„ì‚°
                const rect = e.currentTarget.getBoundingClientRect(); 
                let clientX = e.clientX - rect.left;
                let clientY = e.clientY - rect.top;

                // Y ì¢Œí‘œê°€ ì ìˆ˜íŒ ì˜ì—­(50px)ë³´ë‹¤ ì‘ìœ¼ë©´ ë¬´ì‹œ
                if (clientY < SCORE_BOARD_HEIGHT) return;

                // **Matter.js ìº”ë²„ìŠ¤ ë‚´ì˜ X ì¢Œí‘œ**
                let x = clientX; 
                
                const minX = currentFruit.radius + WALL_THICKNESS;
                const maxX = GAME_WIDTH - currentFruit.radius - WALL_THICKNESS;
                
                x = Math.max(minX, Math.min(maxX, x));
                
                // Matter ë°”ë””ì˜ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (Y ìœ„ì¹˜ëŠ” ìº”ë²„ìŠ¤ ìƒë‹¨ì— ê³ ì •)
                Body.setPosition(currentFruit, { x: x, y: currentFruit.radius });
            }
        }
        
        function handleClick() {
            if (currentFruit && currentFruit.isSleeping && !isDropping) {
                isDropping = true; 
                Body.setSleep(currentFruit, false); 
                currentFruit.isSensor = false; 
                fruits.push(currentFruit);
                currentFruit = null;

                setTimeout(() => {
                    isDropping = false; 
                    spawnNextFruit();
                }, 1000); 
            }
        }

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì • í•¨ìˆ˜
        function setupInputListeners(element) {
            element.addEventListener('mousemove', handleMouseMove);
            element.addEventListener('click', handleClick);
        }

        // --- 4. ì¶©ëŒ ê°ì§€ ë° í•©ì¹˜ê¸° ë¡œì§ ---

        Events.on(engine, 'collisionStart', (event) => {
            const pairs = event.pairs;

            pairs.forEach(pair => {
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;

                if (bodyA.label.startsWith('fruit') && bodyB.label.startsWith('fruit') && 
                    bodyA.fruitIndex === bodyB.fruitIndex && 
                    !bodyA.isMerging && !bodyB.isMerging) {
                        
                    bodyA.isMerging = true;
                    bodyB.isMerging = true;

                    const fruitIndexA = bodyA.fruitIndex;
                    const newIndex = fruitIndexA + 1;

                    // 1. ê¸°ì¡´ ê³¼ì¼ ì œê±° ë° HTML ìš”ì†Œ ì œê±°
                    World.remove(world, [bodyA, bodyB]);
                    if (bodyA.div) bodyA.div.remove();
                    if (bodyB.div) bodyB.div.remove();

                    // 2. ë°°ì—´ì—ì„œ ì œê±°
                    fruits = fruits.filter(f => f !== bodyA && f !== bodyB);

                    // 3. ìƒˆ ê³¼ì¼ ìƒì„±
                    if (newIndex < FRUITS_DATA.length) {
                        const newFruitData = FRUITS_DATA[newIndex];
                        const avgX = (bodyA.position.x + bodyB.position.x) / 2;
                        const avgY = (bodyA.position.y + bodyB.position.y) / 2;
                        const newRadius = newFruitData.radius; 

                        const mergedFruit = Bodies.circle(avgX, avgY, newRadius, {
                            label: `fruit-${newIndex}`,
                            restitution: 0.1,
                            friction: 0.1,
                            density: 0.001,
                            fruitIndex: newIndex,
                            isMerging: false, 
                            render: { visible: false } 
                        });
                        
                        mergedFruit.radius = newRadius;

                        const newFruitDiv = document.createElement('div');
                        newFruitDiv.classList.add('fruit');
                        newFruitDiv.innerHTML = newFruitData.emoji;
                        newFruitDiv.style.width = newFruitDiv.style.height = `${newRadius * 2}px`;
                        newFruitDiv.style.fontSize = `${newRadius * 1.8}px`; 
                        newFruitDiv.style.backgroundColor = newFruitData.color;
                        
                        mergedFruit.div = newFruitDiv;
                        document.getElementById(CANVAS_CONTAINER_ID).appendChild(newFruitDiv);

                        World.add(world, mergedFruit);
                        fruits.push(mergedFruit);

                        score += (newIndex + 1) * 100; 
                        document.getElementById('score').textContent = score;
                    }
                }
            });
        });

        // --- 5. ê²Œì„ ì˜¤ë²„ ì¡°ê±´ ---
        
        const GAME_OVER_LINE_Y = 100; // ìº”ë²„ìŠ¤ ìƒë‹¨ì—ì„œ 100px ì§€ì 
        let gameOverTimer = null;

        Events.on(engine, 'beforeUpdate', () => {
            const isAnyFruitTooHigh = fruits.some(fruit => 
                (fruit.position.y - fruit.radius) < GAME_OVER_LINE_Y && fruit.velocity.y < 0.1 
            );

            if (isAnyFruitTooHigh) {
                if (!gameOverTimer) {
                    gameOverTimer = setTimeout(() => {
                        gameOver();
                    }, 1000); 
                }
            } else {
                clearTimeout(gameOverTimer);
                gameOverTimer = null;
            }
        });


        function gameOver() {
            Runner.stop(runner);
            Render.stop(render);
            
            if (gameContainerElement) {
                gameContainerElement.removeEventListener('mousemove', handleMouseMove);
                gameContainerElement.removeEventListener('click', handleClick);
            }

            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over-overlay').style.display = 'flex';
        }

        // --- ì´ˆê¸° ì‹œì‘ ---
        document.addEventListener('DOMContentLoaded', () => {
            startGame(); 
        });

    </script>
</body>
</html>