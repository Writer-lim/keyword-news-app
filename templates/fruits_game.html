<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìŠˆí¼ ìŠ¤ë¬´ë”” (ê³¼ì¼ í•©ì¹˜ê¸° ê²Œì„)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');
        
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #f3f4f6;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
        }

        #game-container {
            position: relative;
            width: 400px; /* ê²Œì„ ë³´ë“œì˜ ë„ˆë¹„ */
            height: 650px; /* ê²Œì„ ë³´ë“œ ë†’ì´ + ìƒë‹¨ ì ìˆ˜íŒ ê³µê°„ */
            background-color: #ffffff;
            border: 4px solid #10b981; /* ì—ë©”ë„ë“œ 500 */
            border-radius: 12px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            overflow: hidden; /* Matter.js ìº”ë²„ìŠ¤ë‚˜ ê³¼ì¼ì´ ë„˜ì¹˜ì§€ ì•Šë„ë¡ */
        }

        #score-board {
            position: relative;
            z-index: 200; /* ìº”ë²„ìŠ¤ ìœ„ì— í‘œì‹œ */
            padding: 15px;
            background-color: #059669; /* ì—ë©”ë„ë“œ 600 */
            color: white;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.2rem;
            font-weight: bold;
        }

        /* Matter.js ìº”ë²„ìŠ¤ë¥¼ ì»¨í…Œì´ë„ˆì— ë§ê²Œ ìœ„ì¹˜ì‹œí‚´ */
        #game-canvas {
            position: absolute;
            top: 50px; /* ì ìˆ˜íŒ ë†’ì´ë§Œí¼ ì•„ë˜ë¡œ ë‚´ë¦¼ */
            left: 0;
            width: 400px;
            height: 600px;
        }
        
        /* Matter.jsê°€ ìƒì„±í•˜ëŠ” ìº”ë²„ìŠ¤ ìì²´ì— ëŒ€í•œ ìŠ¤íƒ€ì¼ (ì •í™•í•œ ìœ„ì¹˜ ì§€ì •) */
        #game-canvas canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* ê³¼ì¼ ìŠ¤íƒ€ì¼ë§ */
        .fruit {
            position: absolute;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: 900;
            color: #fff;
            user-select: none;
            /* Matter.jsê°€ ë³€í™˜í•œ ìœ„ì¹˜ì— ë§ì¶”ê¸° ìœ„í•´ transform ì‚¬ìš© */
            transform: translate(-50%, -50%); 
            transition: transform 0.05s linear; /* ë¶€ë“œëŸ¬ìš´ ì›€ì§ì„ì„ ìœ„í•´ ì¶”ê°€ */
        }

        /* ê²Œì„ ì˜¤ë²„ ì˜¤ë²„ë ˆì´ */
        #game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            border-radius: 8px;
            z-index: 300;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="score-board">
            <span>ì ìˆ˜: <span id="score">0</span></span>
            <button onclick="startGame()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-1 px-3 rounded text-sm transition-colors">
                ìƒˆ ê²Œì„
            </button>
        </div>

        <div id="game-canvas">
            </div>

        <div id="game-over-overlay">
            <h2 class="text-3xl font-bold text-gray-800 mb-3">ê²Œì„ ì˜¤ë²„!</h2>
            <p class="text-lg text-gray-600 mb-6">ìµœì¢… ì ìˆ˜: <span id="final-score" class="font-extrabold text-red-600">0</span></p>
            <button onclick="startGame()" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded transition-colors">
                ë‹¤ì‹œ ì‹œì‘
            </button>
        </div>
    </div>

    <script>
        // --- Matter.js ì´ˆê¸°í™” ---
        const { Engine, Render, World, Bodies, Events, Body, Runner } = Matter; // Runner ì¶”ê°€

        const CANVAS_OFFSET_Y = 50; // ì ìˆ˜íŒ ë†’ì´ë§Œí¼ ìº”ë²„ìŠ¤ Y ìœ„ì¹˜ ì˜¤í”„ì…‹
        const GAME_WIDTH = 400;
        const GAME_HEIGHT = 600;
        const WALL_THICKNESS = 20;
        const CONTAINER_ID = 'game-canvas';

        let engine;
        let world;
        let render;
        let runner; // ëŸ¬ë„ˆ ê°ì²´ ì¶”ê°€
        let score = 0;
        let currentFruit = null;
        let fruits = []; // í˜„ì¬ ê²Œì„ì— ìˆëŠ” ëª¨ë“  ê³¼ì¼ ê°ì²´
        let isDropping = false; // ê³¼ì¼ì´ ë–¨ì–´ì§€ëŠ” ì¤‘ì¸ì§€ í™•ì¸

        // ê³¼ì¼ í¬ê¸°ì™€ ìƒ‰ìƒ ì •ì˜ (1~11ë‹¨ê³„)
        const FRUITS_DATA = [
            { name: 'ì²´ë¦¬', radius: 15, color: '#f87171', emoji: 'ğŸ’' },    // 1
            { name: 'ë”¸ê¸°', radius: 20, color: '#f43f5e', emoji: 'ğŸ“' },    // 2
            { name: 'í¬ë„', radius: 25, color: '#c084fc', emoji: 'ğŸ‡' },    // 3
            { name: 'ê°ê·¤', radius: 30, color: '#fb923c', emoji: 'ğŸŠ' },    // 4
            { name: 'ë ˆëª¬', radius: 35, color: '#fde047', emoji: 'ğŸ‹' },    // 5
            { name: 'í‚¤ìœ„', radius: 40, color: '#84cc16', emoji: 'ğŸ¥' },    // 6
            { name: 'í† ë§ˆí† ', radius: 45, color: '#ef4444', emoji: 'ğŸ…' },  // 7
            { name: 'ë³µìˆ­ì•„', radius: 50, color: '#fcd34d', emoji: 'ğŸ‘' },  // 8
            { name: 'íŒŒì¸ì• í”Œ', radius: 55, color: '#f59e0b', emoji: 'ğŸ' },// 9
            { name: 'ë©œë¡ ', radius: 60, color: '#4ade80', emoji: 'ğŸˆ' },    // 10
            { name: 'ìˆ˜ë°•', radius: 65, color: '#22c55e', emoji: 'ğŸ‰' }     // 11
        ];

        // --- 1. ê²Œì„ í™˜ê²½ ì„¤ì • ë° ì´ˆê¸°í™” ---

        function setupEngine() {
            engine = Engine.create();
            world = engine.world;
            world.gravity.y = 1; // ê¸°ë³¸ ì¤‘ë ¥ ì„¤ì •

            const canvasContainer = document.getElementById(CONTAINER_ID);

            render = Render.create({
                element: canvasContainer,
                engine: engine,
                options: {
                    width: GAME_WIDTH,
                    height: GAME_HEIGHT,
                    wireframes: false, // ì™€ì´ì–´í”„ë ˆì„ ëŒ€ì‹  ì‹¤ì œ ë Œë”ë§ ì‚¬ìš©
                    background: '#e0f2f1', // ë¯¼íŠ¸ ë°°ê²½
                    showInternalEdges: false,
                    showVelocity: false,
                    showCollisions: false
                }
            });

            Render.run(render);
            runner = Runner.run(Engine.create()); // ëŸ¬ë„ˆë¥¼ ì‚¬ìš©í•˜ì—¬ ì—”ì§„ ë£¨í”„ ì‹¤í–‰
        }

        function createBoundaries() {
            // ë°”ë‹¥ (Floor): Yì¶•ì´ ìº”ë²„ìŠ¤ ë†’ì´(600)ì˜ ì¤‘ì•™ì— ì˜¤ë„ë¡ + WALL_THICKNESS / 2 ë§Œí¼ ë” ë‚´ë ¤ì•¼ í•¨
            const floor = Bodies.rectangle(GAME_WIDTH / 2, GAME_HEIGHT + WALL_THICKNESS / 2, GAME_WIDTH, WALL_THICKNESS, { 
                isStatic: true, 
                label: 'floor',
                render: { fillStyle: '#4b5563' }
            });
            // ì™¼ìª½ ë²½ (Left Wall)
            const leftWall = Bodies.rectangle(-WALL_THICKNESS / 2, GAME_HEIGHT / 2, WALL_THICKNESS, GAME_HEIGHT + 2 * WALL_THICKNESS, { // ì•½ê°„ ë” ê¸¸ê²Œ
                isStatic: true, 
                label: 'wall',
                render: { fillStyle: '#4b5563' }
            });
            // ì˜¤ë¥¸ìª½ ë²½ (Right Wall)
            const rightWall = Bodies.rectangle(GAME_WIDTH + WALL_THICKNESS / 2, GAME_HEIGHT / 2, WALL_THICKNESS, GAME_HEIGHT + 2 * WALL_THICKNESS, { // ì•½ê°„ ë” ê¸¸ê²Œ
                isStatic: true, 
                label: 'wall',
                render: { fillStyle: '#4b5563' }
            });

            World.add(world, [floor, leftWall, rightWall]);
        }

        function startGame() {
            if (engine) {
                // ê¸°ì¡´ ì—”ì§„ ì¤‘ì§€ ë° ì •ë¦¬
                Runner.stop(runner);
                World.clear(world, false);
                Engine.clear(engine);
                Render.stop(render);
                
                // ê¸°ì¡´ ìº”ë²„ìŠ¤ ë° ëª¨ë“  ê³¼ì¼ div ìš”ì†Œ ì •ë¦¬
                const canvasContainer = document.getElementById(CONTAINER_ID);
                canvasContainer.innerHTML = '';
            }

            setupEngine();
            createBoundaries();
            fruits = [];
            score = 0;
            isDropping = false;
            document.getElementById('score').textContent = score;
            document.getElementById('game-over-overlay').style.display = 'none';

            // 0.5ì´ˆ í›„ ì²« ê³¼ì¼ ìƒì„±
            setTimeout(spawnNextFruit, 500); 
        }

        // --- 2. ê³¼ì¼ ìƒì„± ë° ë Œë”ë§ ---

        function getRandomFruitIndex() {
            // ì´ˆê¸°ì—ëŠ” 0ë²ˆ(ì²´ë¦¬)ë¶€í„° 4ë²ˆ(ë ˆëª¬)ê¹Œì§€ë§Œ ëœë¤í•˜ê²Œ ë‚˜ì˜¤ë„ë¡ ì œí•œ
            return Math.floor(Math.random() * 5); 
        }

        function spawnNextFruit() {
            if (currentFruit || isDropping) return;

            const fruitIndex = getRandomFruitIndex();
            const fruitData = FRUITS_DATA[fruitIndex];
            const radius = fruitData.radius;
            
            // ê³¼ì¼ ìƒì„± ìœ„ì¹˜ (ë³´ë“œ ì¤‘ì•™ ìƒë‹¨)
            // Y ìœ„ì¹˜ë¥¼ ìº”ë²„ìŠ¤ ìƒë‹¨ (0)ì— ê°€ê¹ê²Œ ì„¤ì •
            const x = GAME_WIDTH / 2;
            const y = radius; 

            const newFruit = Bodies.circle(x, y, radius, {
                label: `fruit-${fruitIndex}`,
                restitution: 0.1, // ë°˜ë°œ ê³„ìˆ˜ (ì•½ê°„ íŠ•ê¹€)
                friction: 0.1,    // ë§ˆì°° ê³„ìˆ˜ (ì•½ê°„ êµ´ëŸ¬ë‹¤ë‹˜)
                density: 0.001,   // ë°€ë„
                isSleeping: true, // ì´ˆê¸°ì—ëŠ” ì •ì§€ ìƒíƒœ (ë§ˆìš°ìŠ¤ë¥¼ ë”°ë¼ë‹¤ë‹˜)
                isSensor: true,   // ë–¨ì–´ëœ¨ë¦¬ê¸° ì „ê¹Œì§€ëŠ” ì¶©ëŒ ê°ì§€ ì•ˆí•¨ (ì»¤ì„œë¥¼ ë”°ë¼ë‹¤ë‹ˆê¸° ìœ„í•¨)
                render: {
                    fillStyle: fruitData.color,
                    visible: false // Matter.js ê¸°ë³¸ ë Œë”ë§ì€ ìˆ¨ê¹€
                },
                fruitIndex: fruitIndex // ì‚¬ìš©ì ì •ì˜ ì†ì„± ì¶”ê°€
            });
            
            // ê³¼ì¼ ë Œë”ë§ì„ ìœ„í•œ HTML ìš”ì†Œ ìƒì„± (Matter.js ë Œë”ë§ ìœ„ì— ê²¹ì¹˜ê¸°)
            const fruitDiv = document.createElement('div');
            fruitDiv.classList.add('fruit');
            fruitDiv.innerHTML = fruitData.emoji;
            fruitDiv.style.width = fruitDiv.style.height = `${radius * 2}px`;
            fruitDiv.style.fontSize = `${radius * 0.8}px`;
            fruitDiv.style.backgroundColor = fruitData.color;
            
            newFruit.div = fruitDiv; // Matter ë°”ë””ì™€ divë¥¼ ì—°ê²°
            document.getElementById(CONTAINER_ID).appendChild(fruitDiv);

            currentFruit = newFruit;
            World.add(world, currentFruit);
        }

        // Matter.js ë Œë”ë§ ì—…ë°ì´íŠ¸ ì‹œ HTML ìš”ì†Œ ìœ„ì¹˜ ë™ê¸°í™”
        Events.on(engine, 'beforeUpdate', () => {
            // ë–¨ì–´ì§„ ê³¼ì¼ë“¤ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            fruits.forEach(fruit => {
                if (fruit.div) {
                    // Matter ì¢Œí‘œ (x, y)ë¥¼ CSS left/topìœ¼ë¡œ ë³€í™˜
                    // transform: translate(-50%, -50%)ë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ, ë°”ë””ì˜ ì¤‘ì‹¬ ìœ„ì¹˜ë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©
                    fruit.div.style.left = `${fruit.position.x}px`;
                    fruit.div.style.top = `${fruit.position.y}px`;
                }
            });
            
            // í˜„ì¬ ë–¨ì–´ëœ¨ë¦´ ê³¼ì¼ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (ë§ˆìš°ìŠ¤ë¥¼ ë”°ë¼ë‹¤ë‹˜)
            if (currentFruit && currentFruit.isSleeping) {
                 if (currentFruit.div) {
                    currentFruit.div.style.left = `${currentFruit.position.x}px`;
                    currentFruit.div.style.top = `${currentFruit.position.y}px`;
                }
            }
        });

        // --- 3. ì‚¬ìš©ì ì…ë ¥ ì²˜ë¦¬ (ë–¨ì–´ëœ¨ë¦¬ê¸°) ---
        
        const gameCanvas = document.getElementById(CONTAINER_ID);

        // ë§ˆìš°ìŠ¤ ì´ë™ ì‹œ í˜„ì¬ ê³¼ì¼ì˜ x ìœ„ì¹˜ ì—…ë°ì´íŠ¸
        gameCanvas.addEventListener('mousemove', (e) => {
            if (currentFruit && currentFruit.isSleeping && !isDropping) {
                const rect = e.currentTarget.getBoundingClientRect();
                // ìº”ë²„ìŠ¤ ë‚´ì—ì„œì˜ ìƒëŒ€ì ì¸ X ìœ„ì¹˜
                let x = e.clientX - rect.left; 
                
                // ê²½ê³„ ë‚´ ì œí•œ: ë²½ ë‘ê»˜ì™€ ê³¼ì¼ ë°˜ì§€ë¦„ì„ ê³ ë ¤
                const minX = currentFruit.circleRadius + WALL_THICKNESS;
                const maxX = GAME_WIDTH - currentFruit.circleRadius - WALL_THICKNESS;
                
                x = Math.max(minX, Math.min(maxX, x));
                
                // Matter ë°”ë””ì˜ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (Y ìœ„ì¹˜ëŠ” ê³ ì •)
                Body.setPosition(currentFruit, { x: x, y: currentFruit.position.y });
            }
        });
        
        // í´ë¦­ ì‹œ ê³¼ì¼ ë–¨ì–´ëœ¨ë¦¬ê¸°
        gameCanvas.addEventListener('click', () => {
            if (currentFruit && currentFruit.isSleeping && !isDropping) {
                isDropping = true; // ë–¨ì–´ëœ¨ë¦¬ëŠ” ì¤‘ í”Œë˜ê·¸ ì„¤ì •
                Body.setSleep(currentFruit, false); // ì ìê¸° ìƒíƒœ í•´ì œ (ì¤‘ë ¥ ì ìš© ì‹œì‘)
                currentFruit.isSensor = false; // ì¶©ëŒ ê°ì§€ í™œì„±í™”
                fruits.push(currentFruit);
                currentFruit = null;

                // ë‹¤ìŒ ê³¼ì¼ ìƒì„±ì€ ì ì‹œ ì§€ì—° í›„ ì‹¤í–‰
                setTimeout(() => {
                    isDropping = false; // í”Œë˜ê·¸ í•´ì œ
                    spawnNextFruit();
                }, 1000); 
            }
        });

        // --- 4. ì¶©ëŒ ê°ì§€ ë° í•©ì¹˜ê¸° ë¡œì§ ---

        Events.on(engine, 'collisionStart', (event) => {
            const pairs = event.pairs;

            pairs.forEach(pair => {
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;

                // ë‘ ë°”ë”” ëª¨ë‘ ê³¼ì¼ì´ê³ , ê°™ì€ ì¢…ë¥˜ì´ë©°, í•©ì³ì§€ëŠ” ì¤‘ì´ ì•„ë‹ ë•Œ ì²˜ë¦¬
                if (bodyA.label.startsWith('fruit') && bodyB.label.startsWith('fruit') && 
                    bodyA.fruitIndex === bodyB.fruitIndex && 
                    !bodyA.isMerging && !bodyB.isMerging) {
                        
                    // í•©ì¹˜ê¸° ì²˜ë¦¬ ì‹œì‘
                    bodyA.isMerging = true;
                    bodyB.isMerging = true;

                    const fruitIndexA = bodyA.fruitIndex;
                    const newIndex = fruitIndexA + 1;

                    // 1. ê¸°ì¡´ ê³¼ì¼ ì œê±° ë° HTML ìš”ì†Œ ì œê±°
                    World.remove(world, [bodyA, bodyB]);
                    if (bodyA.div) bodyA.div.remove();
                    if (bodyB.div) bodyB.div.remove();

                    // 2. ë°°ì—´ì—ì„œ ì œê±°
                    fruits = fruits.filter(f => f !== bodyA && f !== bodyB);

                    // 3. ìƒˆ ê³¼ì¼ ìƒì„±
                    if (newIndex < FRUITS_DATA.length) {
                        const newFruitData = FRUITS_DATA[newIndex];
                        const avgX = (bodyA.position.x + bodyB.position.x) / 2;
                        const avgY = (bodyA.position.y + bodyB.position.y) / 2;

                        const mergedFruit = Bodies.circle(avgX, avgY, newFruitData.radius, {
                            label: `fruit-${newIndex}`,
                            restitution: 0.1,
                            friction: 0.1,
                            density: 0.001,
                            fruitIndex: newIndex,
                            isMerging: false, // ìƒˆë¡œ ìƒì„±ëœ ê³¼ì¼ì€ í•©ì³ì§€ëŠ” ì¤‘ì´ ì•„ë‹˜
                            render: { visible: false } // Matter.js ê¸°ë³¸ ë Œë”ë§ ìˆ¨ê¹€
                        });
                        
                        // HTML ìš”ì†Œ ìƒì„±
                        const newFruitDiv = document.createElement('div');
                        newFruitDiv.classList.add('fruit');
                        newFruitDiv.innerHTML = newFruitData.emoji;
                        newFruitDiv.style.width = newFruitDiv.style.height = `${newFruitData.radius * 2}px`;
                        newFruitDiv.style.fontSize = `${newFruitData.radius * 0.8}px`;
                        newFruitDiv.style.backgroundColor = newFruitData.color;
                        
                        mergedFruit.div = newFruitDiv;
                        document.getElementById(CONTAINER_ID).appendChild(newFruitDiv);

                        World.add(world, mergedFruit);
                        fruits.push(mergedFruit);

                        // ì ìˆ˜ ì—…ë°ì´íŠ¸ (ë‹¨ê³„ * 100ì )
                        score += (newIndex + 1) * 100; 
                        document.getElementById('score').textContent = score;
                    }
                }
            });
        });

        // --- 5. ê²Œì„ ì˜¤ë²„ ì¡°ê±´ ---
        
        const GAME_OVER_LINE_Y = 100; // ìº”ë²„ìŠ¤ ìƒë‹¨ì—ì„œ 100px ì§€ì 
        let gameOverTimer = null;

        Events.on(engine, 'beforeUpdate', () => {
            // ê³¼ì¼ì´ íŠ¹ì • ë†’ì´(GAME_OVER_LINE_Y)ë¥¼ ë„˜ì–´ì„  ê²½ìš°ë¥¼ í™•ì¸
            const isAnyFruitTooHigh = fruits.some(fruit => 
                fruit.position.y - fruit.circleRadius < GAME_OVER_LINE_Y && fruit.velocity.y < 0.1
            );

            if (isAnyFruitTooHigh) {
                if (!gameOverTimer) {
                    // 1ì´ˆ ë™ì•ˆ ìœ„ì— ë¨¸ë¬´ë¥´ë©´ ê²Œì„ ì˜¤ë²„
                    gameOverTimer = setTimeout(() => {
                        gameOver();
                    }, 1000); 
                }
            } else {
                // ê³¼ì¼ì´ ë‚´ë ¤ê°”ìœ¼ë©´ íƒ€ì´ë¨¸ ë¦¬ì…‹
                clearTimeout(gameOverTimer);
                gameOverTimer = null;
            }
        });


        function gameOver() {
            // ì—”ì§„ ì¤‘ì§€
            Runner.stop(runner);
            Render.stop(render);
            
            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over-overlay').style.display = 'flex';
        }

        // --- ì´ˆê¸° ì‹œì‘ ---
        document.addEventListener('DOMContentLoaded', () => {
            startGame(); 
        });

    </script>
</body>
</html>