<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048 게임</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&display=swap');
        
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #e2e8f0;
        }
        
        #game-board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 12px;
            background-color: #bfae9e;
            padding: 12px;
            border-radius: 8px;
            touch-action: none;
        }

        .grid-cell {
            aspect-ratio: 1 / 1;
            background-color: #ccc0b4;
            border-radius: 4px;
        }

        .tile {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            font-weight: 900;
            color: #776e65;
            border-radius: 4px;
            transition: transform 0.1s ease-in-out, background-color 0.2s, color 0.2s, left 0.2s, top 0.2s;
            z-index: 10;
        }

        /* --- 타일 값에 따른 색상 및 폰트 스타일 --- */
        .tile-2 { background-color: #eee4da; color: #776e65; font-size: 42px; }
        .tile-4 { background-color: #ede0c8; color: #776e65; font-size: 42px; }
        .tile-8 { background-color: #f2b179; color: #f9f6f2; font-size: 42px; }
        .tile-16 { background-color: #f59563; color: #f9f6f2; font-size: 38px; }
        .tile-32 { background-color: #f67c5f; color: #f9f6f2; font-size: 38px; }
        .tile-64 { background-color: #f65e3b; color: #f9f6f2; font-size: 38px; }
        .tile-128 { background-color: #edcf72; color: #f9f6f2; font-size: 32px; }
        .tile-256 { background-color: #edcc61; color: #f9f6f2; font-size: 32px; }
        .tile-512 { background-color: #edc850; color: #f9f6f2; font-size: 32px; }
        .tile-1024 { background-color: #edc53f; color: #f9f6f2; font-size: 28px; }
        .tile-2048 { background-color: #edc22e; color: #f9f6f2; font-size: 28px; }
        .tile-4096, .tile-8192, .tile-16384 {
            background-color: #3c3a32;
            color: #f9f6f2;
            font-size: 24px;
        }

        #game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(238, 228, 218, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            border-radius: 8px;
            z-index: 20;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

    </style>
</head>
<body class="p-4 md:p-8 flex flex-col items-center justify-center min-h-screen">

    <div class="bg-white p-6 md:p-10 rounded-xl shadow-2xl max-w-lg w-full relative">
        
        <header class="flex justify-between items-center mb-6">
            <h1 class="text-4xl font-extrabold text-gray-900 flex items-center">
                <i class="fas fa-dice mr-3 text-red-500"></i> 2048
            </h1>
            <div class="flex items-center space-x-2">
                <div class="bg-gray-200 text-gray-800 font-bold py-2 px-4 rounded-lg text-lg">
                    점수 <span id="score">0</span>
                </div>
                <button id="new-game-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors">
                    새 게임
                </button>
            </div>
        </header>

        <div id="game-over-overlay" class="hidden">
            <h2 class="text-4xl font-bold mb-4 text-gray-900">게임 오버!</h2>
            <p class="text-xl text-gray-700 mb-6">최종 점수: <span id="final-score" class="font-extrabold text-red-600">0</span></p>
            <button onclick="startGame()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition-colors">
                다시 시작
            </button>
        </div>

        <div id="board-container" class="relative">
            <div id="game-board" class="w-full">
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
            </div>
            </div>

        <footer class="mt-6 text-center">
            <p class="text-sm text-gray-600 flex items-center justify-center">
                <i class="fas fa-keyboard mr-2 text-indigo-500"></i>
                화살표 키 (↑, ↓, ←, →)를 사용하여 타일을 이동 및 합치세요.
            </p>
            <a href="/" class="text-indigo-500 hover:text-indigo-700 mt-4 text-lg block transition-colors">
                &larr; 메인 검색 페이지로 돌아가기
            </a>
        </footer>
    </div>

    <script>
        // --- 2048 게임 로직 ---
        
        const BOARD_SIZE = 4;
        const boardContainer = document.getElementById('board-container');
        const gameBoardElement = document.getElementById('game-board');
        const scoreElement = document.getElementById('score');
        const gameOverOverlay = document.getElementById('game-over-overlay');
        
        let board = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(0));
        let score = 0;
        let isGameOver = false;
        
        const tileColors = {
            2: 'tile-2', 4: 'tile-4', 8: 'tile-8', 16: 'tile-16', 32: 'tile-32', 64: 'tile-64',
            128: 'tile-128', 256: 'tile-256', 512: 'tile-512', 1024: 'tile-1024', 2048: 'tile-2048'
        };

        // --- 1. 보드 상태 렌더링 ---
        
        function updateBoardUI() {
            // console.log('DEBUG: updateBoardUI 시작');
            document.querySelectorAll('.tile').forEach(tile => tile.remove());
            
            const cellElements = gameBoardElement.querySelectorAll('.grid-cell');
            if (cellElements.length === 0) {
                 // console.error('ERROR: Grid cells not found. Cannot calculate tile size.');
                 return;
            }

            const cellRect = cellElements[0].getBoundingClientRect();
            const realCellSize = cellRect.width; 
            const realGapSize = 12;

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const value = board[r][c];
                    if (value !== 0) {
                        const tile = document.createElement('div');
                        const tileClass = tileColors[value] || 'tile-4096';
                        
                        tile.classList.add('tile', tileClass);
                        tile.textContent = value;
                        
                        tile.style.width = `${realCellSize}px`;
                        tile.style.height = `${realCellSize}px`;
                        tile.style.left = `${c * (realCellSize + realGapSize) + realGapSize}px`;
                        tile.style.top = `${r * (realCellSize + realGapSize) + realGapSize}px`;
                        
                        boardContainer.appendChild(tile);
                    }
                }
            }
            scoreElement.textContent = score;
            // console.log('DEBUG: updateBoardUI 완료');
        }
        
        // --- 2. 초기화 및 타일 생성 ---
        
        function generateRandomTile() {
            const emptyCells = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] === 0) {
                        emptyCells.push({ r, c });
                    }
                }
            }
            
            if (emptyCells.length > 0) {
                const { r, c } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                board[r][c] = (Math.random() < 0.9) ? 2 : 4;
                return true;
            }
            return false;
        }

        function startGame() {
            // console.log('DEBUG: startGame() 호출됨.');
            board = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(0));
            score = 0;
            isGameOver = false;
            gameOverOverlay.classList.add('hidden');
            
            // 타일 생성 (최소 2개)
            const tile1 = generateRandomTile();
            const tile2 = generateRandomTile(); 
            
            // console.log('DEBUG: 타일 생성 결과:', '1번 성공:', tile1, '2번 성공:', tile2);
            // console.log('DEBUG: 초기 보드 상태 (0: 빈칸):', board.flat());
            
            updateBoardUI();
        }
        
        // --- 3. 게임 로직 (타일 이동 및 합치기) ---
        
        function compress(row) {
            let newRow = row.filter(val => val !== 0);
            let zeros = Array(BOARD_SIZE - newRow.length).fill(0);
            return newRow.concat(zeros);
        }

        function merge(row) {
            for (let i = 0; i < BOARD_SIZE - 1; i++) {
                if (row[i] !== 0 && row[i] === row[i + 1]) {
                    row[i] *= 2;
                    score += row[i];
                    row[i + 1] = 0;
                }
            }
            return compress(row); 
        }

        function rotate(matrix) {
            let N = matrix.length;
            let newMatrix = Array(N).fill(0).map(() => Array(N).fill(0));
            for (let r = 0; r < N; r++) {
                for (let c = 0; c < N; c++) {
                    newMatrix[c][N - 1 - r] = matrix[r][c];
                }
            }
            return newMatrix;
        }

        function move(direction) {
            if (isGameOver) return false;

            let originalBoard = board.map(arr => [...arr]);
            let tempBoard = board.map(arr => [...arr]);

            let rotations = direction;
            for (let i = 0; i < rotations; i++) {
                tempBoard = rotate(tempBoard);
            }

            for (let r = 0; r < BOARD_SIZE; r++) {
                let row = tempBoard[r];
                let compressedRow = compress(row);
                let newRow = merge(compressedRow);
                tempBoard[r] = newRow;
            }

            let antiRotations = (BOARD_SIZE - rotations) % BOARD_SIZE;
            for (let i = 0; i < antiRotations; i++) {
                tempBoard = rotate(tempBoard);
            }
            
            board = tempBoard;

            let moved = (JSON.stringify(originalBoard) !== JSON.stringify(board));

            if (moved) {
                generateRandomTile();
                updateBoardUI();
                checkGameOver();
            }
            
            return moved;
        }

        // --- 4. 게임 종료 조건 ---
        
        function hasMoves() {
            // console.log('DEBUG: hasMoves() 호출됨.');
            // 1. 빈 셀이 있는지 확인
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] === 0) {
                         // console.log('DEBUG: 빈 셀 발견, hasMoves: true');
                         return true; 
                    }
                }
            }

            // 2. 인접한 타일이 합쳐질 수 있는지 확인
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const val = board[r][c];
                    // 가로 체크
                    if (c < BOARD_SIZE - 1 && val === board[r][c + 1]) {
                        // console.log('DEBUG: 가로 합치기 가능, hasMoves: true');
                        return true; 
                    }
                    // 세로 체크
                    if (r < BOARD_SIZE - 1 && val === board[r + 1][c]) {
                        // console.log('DEBUG: 세로 합치기 가능, hasMoves: true');
                        return true; 
                    }
                }
            }
            // console.log('DEBUG: 움직일 공간 없음, hasMoves: false');
            return false;
        }

        function checkGameOver() {
            // console.log('DEBUG: checkGameOver() 호출됨.');
            if (!hasMoves()) {
                isGameOver = true;
                document.getElementById('final-score').textContent = score;
                gameOverOverlay.classList.remove('hidden');
                // console.log('DEBUG: 게임 오버! 오버레이 활성화.');
            }
        }

        // --- 5. 이벤트 리스너 ---
        document.addEventListener('keydown', (e) => {
            if (isGameOver) return;
            // ... (키보드 이벤트 로직)
            let direction = -1;
            switch (e.key) {
                case 'ArrowLeft': direction = 0; break;
                case 'ArrowUp': direction = 1; break;
                case 'ArrowRight': direction = 2; break;
                case 'ArrowDown': direction = 3; break;
            }
            if (direction !== -1) {
                e.preventDefault();
                move(direction);
            }
        });

        document.getElementById('new-game-btn').addEventListener('click', startGame);

        // --- 초기 시작 ---
        document.addEventListener('DOMContentLoaded', startGame);
        
        // --- 터치 이벤트 (모바일 지원) ---
        let startX, startY;
        
        boardContainer.addEventListener('touchstart', (e) => {
            if (isGameOver) return;
            const touch = e.touches[0];
            startX = touch.clientX;
            startY = touch.clientY;
        }, { passive: false });

        boardContainer.addEventListener('touchend', (e) => {
            if (isGameOver) return;
            
            const touch = e.changedTouches[0];
            const endX = touch.clientX;
            const endY = touch.clientY;
            
            const dx = endX - startX;
            const dy = endY - startY;
            
            const threshold = 50; 
            
            if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > threshold) {
                move(dx > 0 ? 2 : 0);
                e.preventDefault();
            } else if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > threshold) {
                move(dy > 0 ? 3 : 1);
                e.preventDefault();
            }
        }, { passive: false });

    </script>
</body>
</html>